["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@material-ui/core/utils/useIsFocusVisible.js"],"~:js","shadow$provide.module$node_modules$$material_ui$core$utils$useIsFocusVisible=function(global,require,module,exports){function handleKeyDown(event){event.metaKey||event.altKey||event.ctrlKey||(hadKeyboardEvent=!0)}function handlePointerDown(){hadKeyboardEvent=!1}function handleVisibilityChange(){\"hidden\"===this.visibilityState&&hadFocusVisibleRecently&&(hadKeyboardEvent=!0)}function isFocusVisible(event){event=event.target;try{return event.matches(\":focus-visible\")}catch(error){}var JSCompiler_temp;\nif(!(JSCompiler_temp=hadKeyboardEvent)){JSCompiler_temp=event.type;var tagName=event.tagName;JSCompiler_temp=\"INPUT\"===tagName&&inputTypesWhitelist[JSCompiler_temp]&&!event.readOnly||\"TEXTAREA\"===tagName&&!event.readOnly||event.isContentEditable?!0:!1}return JSCompiler_temp}function handleBlurVisible(){hadFocusVisibleRecently=!0;window.clearTimeout(hadFocusVisibleRecentlyTimeout);hadFocusVisibleRecentlyTimeout=window.setTimeout(function(){hadFocusVisibleRecently=!1},100)}global=require(\"module$node_modules$$babel$runtime$helpers$interopRequireWildcard\");\nObject.defineProperty(exports,\"__esModule\",{value:!0});exports.teardown=function(doc){doc.removeEventListener(\"keydown\",handleKeyDown,!0);doc.removeEventListener(\"mousedown\",handlePointerDown,!0);doc.removeEventListener(\"pointerdown\",handlePointerDown,!0);doc.removeEventListener(\"touchstart\",handlePointerDown,!0);doc.removeEventListener(\"visibilitychange\",handleVisibilityChange,!0)};exports.default=function(){var ref=React.useCallback(function(instance){instance=ReactDOM.findDOMNode(instance);null!=\ninstance&&(instance=instance.ownerDocument,instance.addEventListener(\"keydown\",handleKeyDown,!0),instance.addEventListener(\"mousedown\",handlePointerDown,!0),instance.addEventListener(\"pointerdown\",handlePointerDown,!0),instance.addEventListener(\"touchstart\",handlePointerDown,!0),instance.addEventListener(\"visibilitychange\",handleVisibilityChange,!0))},[]);React.useDebugValue(isFocusVisible);return{isFocusVisible,onBlurVisible:handleBlurVisible,ref}};var React=global(require(\"module$node_modules$react$index\")),\nReactDOM=global(require(\"module$node_modules$react_dom$index\")),hadKeyboardEvent=!0,hadFocusVisibleRecently=!1,hadFocusVisibleRecentlyTimeout=null,inputTypesWhitelist={text:!0,search:!0,url:!0,tel:!0,email:!0,password:!0,number:!0,date:!0,month:!0,week:!0,time:!0,datetime:!0,\"datetime-local\":!0}}","~:source","shadow$provide[\"module$node_modules$$material_ui$core$utils$useIsFocusVisible\"] = function(global,require,module,exports) {\n\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.teardown = teardown;\nexports.default = useIsFocusVisible;\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar ReactDOM = _interopRequireWildcard(require(\"react-dom\"));\n\n// based on https://github.com/WICG/focus-visible/blob/v4.1.5/src/focus-visible.js\nvar hadKeyboardEvent = true;\nvar hadFocusVisibleRecently = false;\nvar hadFocusVisibleRecentlyTimeout = null;\nvar inputTypesWhitelist = {\n  text: true,\n  search: true,\n  url: true,\n  tel: true,\n  email: true,\n  password: true,\n  number: true,\n  date: true,\n  month: true,\n  week: true,\n  time: true,\n  datetime: true,\n  'datetime-local': true\n};\n/**\n * Computes whether the given element should automatically trigger the\n * `focus-visible` class being added, i.e. whether it should always match\n * `:focus-visible` when focused.\n * @param {Element} node\n * @return {boolean}\n */\n\nfunction focusTriggersKeyboardModality(node) {\n  var type = node.type,\n      tagName = node.tagName;\n\n  if (tagName === 'INPUT' && inputTypesWhitelist[type] && !node.readOnly) {\n    return true;\n  }\n\n  if (tagName === 'TEXTAREA' && !node.readOnly) {\n    return true;\n  }\n\n  if (node.isContentEditable) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * Keep track of our keyboard modality state with `hadKeyboardEvent`.\n * If the most recent user interaction was via the keyboard;\n * and the key press did not include a meta, alt/option, or control key;\n * then the modality is keyboard. Otherwise, the modality is not keyboard.\n * @param {KeyboardEvent} event\n */\n\n\nfunction handleKeyDown(event) {\n  if (event.metaKey || event.altKey || event.ctrlKey) {\n    return;\n  }\n\n  hadKeyboardEvent = true;\n}\n/**\n * If at any point a user clicks with a pointing device, ensure that we change\n * the modality away from keyboard.\n * This avoids the situation where a user presses a key on an already focused\n * element, and then clicks on a different element, focusing it with a\n * pointing device, while we still think we're in keyboard modality.\n */\n\n\nfunction handlePointerDown() {\n  hadKeyboardEvent = false;\n}\n\nfunction handleVisibilityChange() {\n  if (this.visibilityState === 'hidden') {\n    // If the tab becomes active again, the browser will handle calling focus\n    // on the element (Safari actually calls it twice).\n    // If this tab change caused a blur on an element with focus-visible,\n    // re-apply the class when the user switches back to the tab.\n    if (hadFocusVisibleRecently) {\n      hadKeyboardEvent = true;\n    }\n  }\n}\n\nfunction prepare(doc) {\n  doc.addEventListener('keydown', handleKeyDown, true);\n  doc.addEventListener('mousedown', handlePointerDown, true);\n  doc.addEventListener('pointerdown', handlePointerDown, true);\n  doc.addEventListener('touchstart', handlePointerDown, true);\n  doc.addEventListener('visibilitychange', handleVisibilityChange, true);\n}\n\nfunction teardown(doc) {\n  doc.removeEventListener('keydown', handleKeyDown, true);\n  doc.removeEventListener('mousedown', handlePointerDown, true);\n  doc.removeEventListener('pointerdown', handlePointerDown, true);\n  doc.removeEventListener('touchstart', handlePointerDown, true);\n  doc.removeEventListener('visibilitychange', handleVisibilityChange, true);\n}\n\nfunction isFocusVisible(event) {\n  var target = event.target;\n\n  try {\n    return target.matches(':focus-visible');\n  } catch (error) {// browsers not implementing :focus-visible will throw a SyntaxError\n    // we use our own heuristic for those browsers\n    // rethrow might be better if it's not the expected error but do we really\n    // want to crash if focus-visible malfunctioned?\n  } // no need for validFocusTarget check. the user does that by attaching it to\n  // focusable events only\n\n\n  return hadKeyboardEvent || focusTriggersKeyboardModality(target);\n}\n/**\n * Should be called if a blur event is fired on a focus-visible element\n */\n\n\nfunction handleBlurVisible() {\n  // To detect a tab/window switch, we look for a blur event followed\n  // rapidly by a visibility change.\n  // If we don't see a visibility change within 100ms, it's probably a\n  // regular focus change.\n  hadFocusVisibleRecently = true;\n  window.clearTimeout(hadFocusVisibleRecentlyTimeout);\n  hadFocusVisibleRecentlyTimeout = window.setTimeout(function () {\n    hadFocusVisibleRecently = false;\n  }, 100);\n}\n\nfunction useIsFocusVisible() {\n  var ref = React.useCallback(function (instance) {\n    var node = ReactDOM.findDOMNode(instance);\n\n    if (node != null) {\n      prepare(node.ownerDocument);\n    }\n  }, []);\n\n  if (process.env.NODE_ENV !== 'production') {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useDebugValue(isFocusVisible);\n  }\n\n  return {\n    isFocusVisible: isFocusVisible,\n    onBlurVisible: handleBlurVisible,\n    ref: ref\n  };\n}\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$$babel$runtime$helpers$interopRequireWildcard","~$module$node_modules$react_dom$index","~$module$node_modules$react$index","~$shadow.js"]],"~:properties",["^5",["url","__esModule","tel","email","teardown","value","text","number","week","time","datetime","onBlurVisible","ref","password","isFocusVisible","date","month","search","default"]],"~:compiled-at",1622892591840,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$material_ui$core$utils$useIsFocusVisible.js\",\n\"lineCount\":5,\n\"mappings\":\"AAAAA,cAAA,8DAAA,CAAkF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAqE1HC,QAASA,cAAa,CAACC,KAAD,CAAQ,CACxBA,KAAAC,QAAJ,EAAqBD,KAAAE,OAArB,EAAqCF,KAAAG,QAArC,GAIAC,gBAJA,CAImB,CAAA,CAJnB,CAD4B,CAgB9BC,QAASA,kBAAiB,EAAG,CAC3BD,gBAAA,CAAmB,CAAA,CADQ,CAI7BE,QAASA,uBAAsB,EAAG,CACH,QAA7B,GAAI,IAAAC,gBAAJ,EAKMC,uBALN,GAMIJ,gBANJ,CAMuB,CAAA,CANvB,CADgC,CA4BlCK,QAASA,eAAc,CAACT,KAAD,CAAQ,CACzBU,KAAAA,CAASV,KAAAU,OAEb,IAAI,CACF,MAAOA,MAAAC,QAAA,CAAe,gBAAf,CADL,CAEF,MAAOC,KAAP,CAAc,EAQT,IAAA,eAAA;GAAAR,EAAAA,eAAAA,CAAAA,gBAAAA,CAAA,CAAA,CAvFHS,eAAAA,CAuFuBC,KAvFhBD,KAAX,KACIE,QAsFuBD,KAtFbC,QAUd,gBAAA,CARgB,OAQhB,GARIA,OAQJ,EAR2BC,mBAAA,CAAoBH,eAApB,CAQ3B,EARwD,CAoF7BC,KApF8BG,SAQzD,EAJgB,UAIhB,GAJIF,OAIJ,EAJ8B,CAgFHD,KAhFIG,SAI/B,EA4E2BH,KA5EvBI,kBAAJ,CACS,CAAA,CADT,CAIO,CAAA,CAwEA,CAAP,MAAO,gBAbsB,CAoB/BC,QAASA,kBAAiB,EAAG,CAK3BX,uBAAA,CAA0B,CAAA,CAC1BY,OAAAC,aAAA,CAAoBC,8BAApB,CACAA,+BAAA,CAAiCF,MAAAG,WAAA,CAAkB,QAAS,EAAG,CAC7Df,uBAAA,CAA0B,CAAA,CADmC,CAA9B,CAE9B,GAF8B,CAPN,CAtIzBgB,MAAAA,CAA0B5B,OAAA,CAAQ,mEAAR,CAE9B6B;MAAAC,eAAA,CAAsB5B,OAAtB,CAA+B,YAA/B,CAA6C,CAC3C6B,MAAO,CAAA,CADoC,CAA7C,CAGA7B,QAAA8B,SAAA,CAqGAA,QAAiB,CAACC,GAAD,CAAM,CACrBA,GAAAC,oBAAA,CAAwB,SAAxB,CAAmC/B,aAAnC,CAAkD,CAAA,CAAlD,CACA8B,IAAAC,oBAAA,CAAwB,WAAxB,CAAqCzB,iBAArC,CAAwD,CAAA,CAAxD,CACAwB,IAAAC,oBAAA,CAAwB,aAAxB,CAAuCzB,iBAAvC,CAA0D,CAAA,CAA1D,CACAwB,IAAAC,oBAAA,CAAwB,YAAxB,CAAsCzB,iBAAtC,CAAyD,CAAA,CAAzD,CACAwB,IAAAC,oBAAA,CAAwB,kBAAxB,CAA4CxB,sBAA5C,CAAoE,CAAA,CAApE,CALqB,CApGvBR,QAAAiC,QAAA,CA4IAC,QAA0B,EAAG,CAC3B,IAAIC,IAAMC,KAAAC,YAAA,CAAkB,QAAS,CAACC,QAAD,CAAW,CAC1CtB,QAAAA,CAAOuB,QAAAC,YAAA,CAAqBF,QAArB,CAEC,KAAZ;AAAItB,QAAJ,GACUyB,QAhDZ,CAgDYzB,QAAAyB,cAhDZ,CAJAV,QAAAW,iBAAA,CAAqB,SAArB,CAAgCzC,aAAhC,CAA+C,CAAA,CAA/C,CAIA,CAHA8B,QAAAW,iBAAA,CAAqB,WAArB,CAAkCnC,iBAAlC,CAAqD,CAAA,CAArD,CAGA,CAFAwB,QAAAW,iBAAA,CAAqB,aAArB,CAAoCnC,iBAApC,CAAuD,CAAA,CAAvD,CAEA,CADAwB,QAAAW,iBAAA,CAAqB,YAArB,CAAmCnC,iBAAnC,CAAsD,CAAA,CAAtD,CACA,CAAAwB,QAAAW,iBAAA,CAAqB,kBAArB,CAAyClC,sBAAzC,CAAiE,CAAA,CAAjE,CA+CE,CAH8C,CAAtC,CAMP,EANO,CAUR4B,MAAAO,cAAA,CAAoBhC,cAApB,CAGF,OAAO,CACWA,cADX,CAELiC,cAAevB,iBAFV,CAGAc,GAHA,CAdoB,CA1I7B,KAAIC,MAAQV,MAAA,CAAwB5B,OAAA,CAAQ,iCAAR,CAAxB,CAAZ;AAEIyC,SAAWb,MAAA,CAAwB5B,OAAA,CAAQ,qCAAR,CAAxB,CAFf,CAKIQ,iBAAmB,CAAA,CALvB,CAMII,wBAA0B,CAAA,CAN9B,CAOIc,+BAAiC,IAPrC,CAQIN,oBAAsB,CACxB2B,KAAM,CAAA,CADkB,CAExBC,OAAQ,CAAA,CAFgB,CAGxBC,IAAK,CAAA,CAHmB,CAIxBC,IAAK,CAAA,CAJmB,CAKxBC,MAAO,CAAA,CALiB,CAMxBC,SAAU,CAAA,CANc,CAOxBC,OAAQ,CAAA,CAPgB,CAQxBC,KAAM,CAAA,CARkB,CASxBC,MAAO,CAAA,CATiB,CAUxBC,KAAM,CAAA,CAVkB,CAWxBC,KAAM,CAAA,CAXkB,CAYxBC,SAAU,CAAA,CAZc,CAaxB,iBAAkB,CAAA,CAbM,CAnBgG;\",\n\"sources\":[\"node_modules/@material-ui/core/utils/useIsFocusVisible.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$material_ui$core$utils$useIsFocusVisible\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nvar _interopRequireWildcard = require(\\\"@babel/runtime/helpers/interopRequireWildcard\\\");\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.teardown = teardown;\\nexports.default = useIsFocusVisible;\\n\\nvar React = _interopRequireWildcard(require(\\\"react\\\"));\\n\\nvar ReactDOM = _interopRequireWildcard(require(\\\"react-dom\\\"));\\n\\n// based on https://github.com/WICG/focus-visible/blob/v4.1.5/src/focus-visible.js\\nvar hadKeyboardEvent = true;\\nvar hadFocusVisibleRecently = false;\\nvar hadFocusVisibleRecentlyTimeout = null;\\nvar inputTypesWhitelist = {\\n  text: true,\\n  search: true,\\n  url: true,\\n  tel: true,\\n  email: true,\\n  password: true,\\n  number: true,\\n  date: true,\\n  month: true,\\n  week: true,\\n  time: true,\\n  datetime: true,\\n  'datetime-local': true\\n};\\n/**\\n * Computes whether the given element should automatically trigger the\\n * `focus-visible` class being added, i.e. whether it should always match\\n * `:focus-visible` when focused.\\n * @param {Element} node\\n * @return {boolean}\\n */\\n\\nfunction focusTriggersKeyboardModality(node) {\\n  var type = node.type,\\n      tagName = node.tagName;\\n\\n  if (tagName === 'INPUT' && inputTypesWhitelist[type] && !node.readOnly) {\\n    return true;\\n  }\\n\\n  if (tagName === 'TEXTAREA' && !node.readOnly) {\\n    return true;\\n  }\\n\\n  if (node.isContentEditable) {\\n    return true;\\n  }\\n\\n  return false;\\n}\\n/**\\n * Keep track of our keyboard modality state with `hadKeyboardEvent`.\\n * If the most recent user interaction was via the keyboard;\\n * and the key press did not include a meta, alt/option, or control key;\\n * then the modality is keyboard. Otherwise, the modality is not keyboard.\\n * @param {KeyboardEvent} event\\n */\\n\\n\\nfunction handleKeyDown(event) {\\n  if (event.metaKey || event.altKey || event.ctrlKey) {\\n    return;\\n  }\\n\\n  hadKeyboardEvent = true;\\n}\\n/**\\n * If at any point a user clicks with a pointing device, ensure that we change\\n * the modality away from keyboard.\\n * This avoids the situation where a user presses a key on an already focused\\n * element, and then clicks on a different element, focusing it with a\\n * pointing device, while we still think we're in keyboard modality.\\n */\\n\\n\\nfunction handlePointerDown() {\\n  hadKeyboardEvent = false;\\n}\\n\\nfunction handleVisibilityChange() {\\n  if (this.visibilityState === 'hidden') {\\n    // If the tab becomes active again, the browser will handle calling focus\\n    // on the element (Safari actually calls it twice).\\n    // If this tab change caused a blur on an element with focus-visible,\\n    // re-apply the class when the user switches back to the tab.\\n    if (hadFocusVisibleRecently) {\\n      hadKeyboardEvent = true;\\n    }\\n  }\\n}\\n\\nfunction prepare(doc) {\\n  doc.addEventListener('keydown', handleKeyDown, true);\\n  doc.addEventListener('mousedown', handlePointerDown, true);\\n  doc.addEventListener('pointerdown', handlePointerDown, true);\\n  doc.addEventListener('touchstart', handlePointerDown, true);\\n  doc.addEventListener('visibilitychange', handleVisibilityChange, true);\\n}\\n\\nfunction teardown(doc) {\\n  doc.removeEventListener('keydown', handleKeyDown, true);\\n  doc.removeEventListener('mousedown', handlePointerDown, true);\\n  doc.removeEventListener('pointerdown', handlePointerDown, true);\\n  doc.removeEventListener('touchstart', handlePointerDown, true);\\n  doc.removeEventListener('visibilitychange', handleVisibilityChange, true);\\n}\\n\\nfunction isFocusVisible(event) {\\n  var target = event.target;\\n\\n  try {\\n    return target.matches(':focus-visible');\\n  } catch (error) {// browsers not implementing :focus-visible will throw a SyntaxError\\n    // we use our own heuristic for those browsers\\n    // rethrow might be better if it's not the expected error but do we really\\n    // want to crash if focus-visible malfunctioned?\\n  } // no need for validFocusTarget check. the user does that by attaching it to\\n  // focusable events only\\n\\n\\n  return hadKeyboardEvent || focusTriggersKeyboardModality(target);\\n}\\n/**\\n * Should be called if a blur event is fired on a focus-visible element\\n */\\n\\n\\nfunction handleBlurVisible() {\\n  // To detect a tab/window switch, we look for a blur event followed\\n  // rapidly by a visibility change.\\n  // If we don't see a visibility change within 100ms, it's probably a\\n  // regular focus change.\\n  hadFocusVisibleRecently = true;\\n  window.clearTimeout(hadFocusVisibleRecentlyTimeout);\\n  hadFocusVisibleRecentlyTimeout = window.setTimeout(function () {\\n    hadFocusVisibleRecently = false;\\n  }, 100);\\n}\\n\\nfunction useIsFocusVisible() {\\n  var ref = React.useCallback(function (instance) {\\n    var node = ReactDOM.findDOMNode(instance);\\n\\n    if (node != null) {\\n      prepare(node.ownerDocument);\\n    }\\n  }, []);\\n\\n  if (process.env.NODE_ENV !== 'production') {\\n    // eslint-disable-next-line react-hooks/rules-of-hooks\\n    React.useDebugValue(isFocusVisible);\\n  }\\n\\n  return {\\n    isFocusVisible: isFocusVisible,\\n    onBlurVisible: handleBlurVisible,\\n    ref: ref\\n  };\\n}\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"handleKeyDown\",\"event\",\"metaKey\",\"altKey\",\"ctrlKey\",\"hadKeyboardEvent\",\"handlePointerDown\",\"handleVisibilityChange\",\"visibilityState\",\"hadFocusVisibleRecently\",\"isFocusVisible\",\"target\",\"matches\",\"error\",\"type\",\"node\",\"tagName\",\"inputTypesWhitelist\",\"readOnly\",\"isContentEditable\",\"handleBlurVisible\",\"window\",\"clearTimeout\",\"hadFocusVisibleRecentlyTimeout\",\"setTimeout\",\"_interopRequireWildcard\",\"Object\",\"defineProperty\",\"value\",\"teardown\",\"doc\",\"removeEventListener\",\"default\",\"useIsFocusVisible\",\"ref\",\"React\",\"useCallback\",\"instance\",\"ReactDOM\",\"findDOMNode\",\"ownerDocument\",\"addEventListener\",\"useDebugValue\",\"onBlurVisible\",\"text\",\"search\",\"url\",\"tel\",\"email\",\"password\",\"number\",\"date\",\"month\",\"week\",\"time\",\"datetime\"]\n}\n"]