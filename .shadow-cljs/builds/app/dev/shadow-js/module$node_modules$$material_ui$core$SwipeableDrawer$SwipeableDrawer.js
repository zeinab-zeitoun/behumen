["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/@material-ui/core/SwipeableDrawer/SwipeableDrawer.js"],"~:js","shadow$provide.module$node_modules$$material_ui$core$SwipeableDrawer$SwipeableDrawer=function(global,require,module,exports){function calculateCurrentX(anchor,touches){return\"right\"===anchor?document.body.offsetWidth-touches[0].pageX:touches[0].pageX}function calculateCurrentY(anchor,touches){return\"bottom\"===anchor?window.innerHeight-touches[0].clientY:touches[0].clientY}function getMaxTranslate(horizontalSwipe,paperInstance){return horizontalSwipe?paperInstance.clientWidth:paperInstance.clientHeight}\nfunction findNativeHandler(_ref){var start=_ref.start,current=_ref.current,anchor=_ref.anchor,JSCompiler_object_inline_scrollPosition_33={x:\"scrollLeft\",y:\"scrollTop\"},JSCompiler_object_inline_scrollLength_34={x:\"scrollWidth\",y:\"scrollHeight\"},JSCompiler_object_inline_clientLength_35={x:\"clientWidth\",y:\"clientHeight\"};return _ref.domTreeShapes.some(function(shape){var goingForward=current>=start;if(\"top\"===anchor||\"left\"===anchor)goingForward=!goingForward;var axis=\"left\"===anchor||\"right\"===anchor?\n\"x\":\"y\",scrollPosition=shape[JSCompiler_object_inline_scrollPosition_33[axis]];axis=scrollPosition+shape[JSCompiler_object_inline_clientLength_35[axis]]<shape[JSCompiler_object_inline_scrollLength_34[axis]];return goingForward&&axis||!goingForward&&0<scrollPosition?shape:null})}var _interopRequireWildcard=require(\"module$node_modules$$babel$runtime$helpers$interopRequireWildcard\"),_interopRequireDefault=require(\"module$node_modules$$babel$runtime$helpers$interopRequireDefault\");Object.defineProperty(exports,\n\"__esModule\",{value:!0});exports.reset=function(){nodeThatClaimedTheSwipe=null};exports.default=void 0;var _objectWithoutProperties2=_interopRequireDefault(require(\"module$node_modules$$babel$runtime$helpers$objectWithoutProperties\")),_extends2=_interopRequireDefault(require(\"module$node_modules$$babel$runtime$helpers$extends\")),React=_interopRequireWildcard(require(\"module$node_modules$react$index\"));global=_interopRequireDefault(require(\"module$node_modules$prop_types$index\"));var ReactDOM=_interopRequireWildcard(require(\"module$node_modules$react_dom$index\"));\nmodule=require(\"module$node_modules$$material_ui$utils$index\");var _styles=require(\"module$node_modules$$material_ui$styles$index\"),_Drawer=_interopRequireWildcard(require(\"module$node_modules$$material_ui$core$Drawer$Drawer\")),_ownerDocument=_interopRequireDefault(require(\"module$node_modules$$material_ui$core$utils$ownerDocument\")),_useEventCallback=_interopRequireDefault(require(\"module$node_modules$$material_ui$core$utils$useEventCallback\"));_interopRequireWildcard=require(\"module$node_modules$$material_ui$core$styles$transitions\");\nvar _useTheme=_interopRequireDefault(require(\"module$node_modules$$material_ui$core$styles$useTheme\")),_utils2=require(\"module$node_modules$$material_ui$core$transitions$utils\"),_NoSsr=_interopRequireDefault(require(\"module$node_modules$$material_ui$core$NoSsr$index\")),_SwipeArea=_interopRequireDefault(require(\"module$node_modules$$material_ui$core$SwipeableDrawer$SwipeArea\")),nodeThatClaimedTheSwipe=null,iOS=\"undefined\"!==typeof navigator&&/iPad|iPhone|iPod/.test(navigator.userAgent),transitionDurationDefault=\n{enter:_interopRequireWildcard.duration.enteringScreen,exit:_interopRequireWildcard.duration.leavingScreen},useEnhancedEffect=\"undefined\"!==typeof window?React.useLayoutEffect:React.useEffect;require=React.forwardRef(function(inProps,ref){var theme=(0,_useTheme.default)();inProps=(0,_styles.getThemeProps)({name:\"MuiSwipeableDrawer\",props:(0,_extends2.default)({},inProps),theme});var _props$anchor=inProps.anchor,anchor=void 0===_props$anchor?\"left\":_props$anchor;_props$anchor=inProps.disableBackdropTransition;\nvar disableBackdropTransition=void 0===_props$anchor?!1:_props$anchor;_props$anchor=inProps.disableDiscovery;var disableDiscovery=void 0===_props$anchor?!1:_props$anchor;_props$anchor=inProps.disableSwipeToOpen;var disableSwipeToOpen=void 0===_props$anchor?iOS:_props$anchor,hideBackdrop=inProps.hideBackdrop;_props$anchor=inProps.hysteresis;var hysteresis=void 0===_props$anchor?.52:_props$anchor;_props$anchor=inProps.minFlingVelocity;var minFlingVelocity=void 0===_props$anchor?450:_props$anchor,_props$ModalProps=\ninProps.ModalProps;_props$ModalProps=void 0===_props$ModalProps?{}:_props$ModalProps;_props$anchor=_props$ModalProps.BackdropProps;_props$ModalProps=(0,_objectWithoutProperties2.default)(_props$ModalProps,[\"BackdropProps\"]);var onClose=inProps.onClose,onOpen=inProps.onOpen,open=inProps.open,_props$PaperProps=inProps.PaperProps;_props$PaperProps=void 0===_props$PaperProps?{}:_props$PaperProps;var SwipeAreaProps=inProps.SwipeAreaProps,_props$swipeAreaWidth=inProps.swipeAreaWidth,swipeAreaWidth=void 0===\n_props$swipeAreaWidth?20:_props$swipeAreaWidth;_props$swipeAreaWidth=inProps.transitionDuration;var transitionDuration=void 0===_props$swipeAreaWidth?transitionDurationDefault:_props$swipeAreaWidth;_props$swipeAreaWidth=inProps.variant;var variant=void 0===_props$swipeAreaWidth?\"temporary\":_props$swipeAreaWidth;inProps=(0,_objectWithoutProperties2.default)(inProps,\"anchor disableBackdropTransition disableDiscovery disableSwipeToOpen hideBackdrop hysteresis minFlingVelocity ModalProps onClose onOpen open PaperProps SwipeAreaProps swipeAreaWidth transitionDuration variant\".split(\" \"));\nvar _React$useState=React.useState(!1);_props$swipeAreaWidth=_React$useState[0];var setMaybeSwiping=_React$useState[1],swipeInstance=React.useRef({isSwiping:null}),swipeAreaRef=React.useRef(),backdropRef=React.useRef(),paperRef=React.useRef(),touchDetected=React.useRef(!1),calculatedDurationRef=React.useRef();useEnhancedEffect(function(){calculatedDurationRef.current=null},[open]);var setPosition=React.useCallback(function(translate){var options=1<arguments.length&&void 0!==arguments[1]?arguments[1]:\n{},_options$mode=options.mode;_options$mode=void 0===_options$mode?null:_options$mode;options=options.changeTransition;options=void 0===options?!0:options;var anchorRtl=(0,_Drawer.getAnchor)(theme,anchor),rtlTranslateMultiplier=-1!==[\"right\",\"bottom\"].indexOf(anchorRtl)?1:-1,transform=(anchorRtl=(0,_Drawer.isHorizontal)(anchor))?\"translate(\".concat(rtlTranslateMultiplier*translate,\"px, 0)\"):\"translate(0, \".concat(rtlTranslateMultiplier*translate,\"px)\");rtlTranslateMultiplier=paperRef.current.style;\nrtlTranslateMultiplier.webkitTransform=transform;rtlTranslateMultiplier.transform=transform;transform=\"\";_options$mode&&(transform=theme.transitions.create(\"all\",(0,_utils2.getTransitionProps)({timeout:transitionDuration},{mode:_options$mode})));options&&(rtlTranslateMultiplier.webkitTransition=transform,rtlTranslateMultiplier.transition=transform);disableBackdropTransition||hideBackdrop||(_options$mode=backdropRef.current.style,_options$mode.opacity=1-translate/getMaxTranslate(anchorRtl,paperRef.current),\noptions&&(_options$mode.webkitTransition=transform,_options$mode.transition=transform))},[anchor,disableBackdropTransition,hideBackdrop,theme,transitionDuration]),handleBodyTouchEnd=(0,_useEventCallback.default)(function(event){if(touchDetected.current)if(nodeThatClaimedTheSwipe=null,touchDetected.current=!1,setMaybeSwiping(!1),swipeInstance.current.isSwiping){swipeInstance.current.isSwiping=null;var anchorRtl=(0,_Drawer.getAnchor)(theme,anchor),horizontal=(0,_Drawer.isHorizontal)(anchor);anchorRtl=\nhorizontal?calculateCurrentX(anchorRtl,event.changedTouches):calculateCurrentY(anchorRtl,event.changedTouches);var startLocation=horizontal?swipeInstance.current.startX:swipeInstance.current.startY;event=getMaxTranslate(horizontal,paperRef.current);anchorRtl=Math.min(Math.max(open?startLocation-anchorRtl:event+startLocation-anchorRtl,0),event);startLocation=anchorRtl/event;Math.abs(swipeInstance.current.velocity)>minFlingVelocity&&(calculatedDurationRef.current=1E3*Math.abs((event-anchorRtl)/swipeInstance.current.velocity));\nopen?swipeInstance.current.velocity>minFlingVelocity||startLocation>hysteresis?onClose():setPosition(0,{mode:\"exit\"}):swipeInstance.current.velocity<-minFlingVelocity||1-startLocation>hysteresis?onOpen():setPosition(getMaxTranslate(horizontal,paperRef.current),{mode:\"enter\"})}else swipeInstance.current.isSwiping=null}),handleBodyTouchMove=(0,_useEventCallback.default)(function(event){if(paperRef.current&&touchDetected.current&&(null==nodeThatClaimedTheSwipe||nodeThatClaimedTheSwipe===swipeInstance.current)){var anchorRtl=\n(0,_Drawer.getAnchor)(theme,anchor),horizontalSwipe=(0,_Drawer.isHorizontal)(anchor),currentX=calculateCurrentX(anchorRtl,event.touches);anchorRtl=calculateCurrentY(anchorRtl,event.touches);if(open&&paperRef.current.contains(event.target)&&null==nodeThatClaimedTheSwipe){for(var element=event.target,rootNode=paperRef.current,domTreeShapes=[];element&&element!==rootNode;){var style=window.getComputedStyle(element);\"absolute\"===style.getPropertyValue(\"position\")||\"hidden\"===style.getPropertyValue(\"overflow-x\")?\ndomTreeShapes=[]:(0<element.clientWidth&&element.scrollWidth>element.clientWidth||0<element.clientHeight&&element.scrollHeight>element.clientHeight)&&domTreeShapes.push(element);element=element.parentElement}if(element=findNativeHandler({domTreeShapes,start:horizontalSwipe?swipeInstance.current.startX:swipeInstance.current.startY,current:horizontalSwipe?currentX:anchorRtl,anchor})){nodeThatClaimedTheSwipe=element;return}nodeThatClaimedTheSwipe=swipeInstance.current}if(null==swipeInstance.current.isSwiping&&\n(element=Math.abs(currentX-swipeInstance.current.startX),rootNode=Math.abs(anchorRtl-swipeInstance.current.startY),element>rootNode&&event.cancelable&&event.preventDefault(),domTreeShapes=horizontalSwipe?element>rootNode&&3<element:rootNode>element&&3<rootNode,!0===domTreeShapes||(horizontalSwipe?3<rootNode:3<element))){swipeInstance.current.isSwiping=domTreeShapes;if(!domTreeShapes){handleBodyTouchEnd(event);return}swipeInstance.current.startX=currentX;swipeInstance.current.startY=anchorRtl;disableDiscovery||\nopen||(horizontalSwipe?swipeInstance.current.startX-=swipeAreaWidth:swipeInstance.current.startY-=swipeAreaWidth)}if(swipeInstance.current.isSwiping){element=getMaxTranslate(horizontalSwipe,paperRef.current);rootNode=horizontalSwipe?swipeInstance.current.startX:swipeInstance.current.startY;open&&!swipeInstance.current.paperHit&&(rootNode=Math.min(rootNode,element));domTreeShapes=horizontalSwipe?currentX:anchorRtl;rootNode=Math.min(Math.max(open?rootNode-domTreeShapes:element+rootNode-domTreeShapes,\n0),element);if(open)if(swipeInstance.current.paperHit)0===rootNode&&(swipeInstance.current.startX=currentX,swipeInstance.current.startY=anchorRtl);else if(horizontalSwipe?currentX<element:anchorRtl<element)swipeInstance.current.paperHit=!0,swipeInstance.current.startX=currentX,swipeInstance.current.startY=anchorRtl;else return;null===swipeInstance.current.lastTranslate&&(swipeInstance.current.lastTranslate=rootNode,swipeInstance.current.lastTime=performance.now()+1);horizontalSwipe=(rootNode-swipeInstance.current.lastTranslate)/\n(performance.now()-swipeInstance.current.lastTime)*1E3;swipeInstance.current.velocity=.4*swipeInstance.current.velocity+.6*horizontalSwipe;swipeInstance.current.lastTranslate=rootNode;swipeInstance.current.lastTime=performance.now();event.cancelable&&event.preventDefault();setPosition(rootNode)}}}),handleBodyTouchStart=(0,_useEventCallback.default)(function(event){if(!event.defaultPrevented&&!event.muiHandled&&(!open||backdropRef.current.contains(event.target)||paperRef.current.contains(event.target))){var anchorRtl=\n(0,_Drawer.getAnchor)(theme,anchor),horizontalSwipe=(0,_Drawer.isHorizontal)(anchor),currentX=calculateCurrentX(anchorRtl,event.touches);anchorRtl=calculateCurrentY(anchorRtl,event.touches);if(!open){if(disableSwipeToOpen||event.target!==swipeAreaRef.current)return;if(horizontalSwipe){if(currentX>swipeAreaWidth)return}else if(anchorRtl>swipeAreaWidth)return}event.muiHandled=!0;nodeThatClaimedTheSwipe=null;swipeInstance.current.startX=currentX;swipeInstance.current.startY=anchorRtl;setMaybeSwiping(!0);\n!open&&paperRef.current&&setPosition(getMaxTranslate(horizontalSwipe,paperRef.current)+(disableDiscovery?20:-swipeAreaWidth),{changeTransition:!1});swipeInstance.current.velocity=0;swipeInstance.current.lastTime=null;swipeInstance.current.lastTranslate=null;swipeInstance.current.paperHit=!1;touchDetected.current=!0}});React.useEffect(function(){if(\"temporary\"===variant){var doc=(0,_ownerDocument.default)(paperRef.current);doc.addEventListener(\"touchstart\",handleBodyTouchStart);doc.addEventListener(\"touchmove\",\nhandleBodyTouchMove,{passive:!1});doc.addEventListener(\"touchend\",handleBodyTouchEnd);return function(){doc.removeEventListener(\"touchstart\",handleBodyTouchStart);doc.removeEventListener(\"touchmove\",handleBodyTouchMove,{passive:!1});doc.removeEventListener(\"touchend\",handleBodyTouchEnd)}}},[variant,handleBodyTouchStart,handleBodyTouchMove,handleBodyTouchEnd]);React.useEffect(function(){return function(){nodeThatClaimedTheSwipe===swipeInstance.current&&(nodeThatClaimedTheSwipe=null)}},[]);React.useEffect(function(){open||\nsetMaybeSwiping(!1)},[open]);_React$useState=React.useCallback(function(instance){backdropRef.current=ReactDOM.findDOMNode(instance)},[]);return React.createElement(React.Fragment,null,React.createElement(_Drawer.default,(0,_extends2.default)({open:\"temporary\"===variant&&_props$swipeAreaWidth?!0:open,variant,ModalProps:(0,_extends2.default)({BackdropProps:(0,_extends2.default)({},_props$anchor,{ref:_React$useState})},_props$ModalProps),PaperProps:(0,_extends2.default)({},_props$PaperProps,{style:(0,\n_extends2.default)({pointerEvents:\"temporary\"!==variant||open?\"\":\"none\"},_props$PaperProps.style),ref:paperRef}),anchor,transitionDuration:calculatedDurationRef.current||transitionDuration,onClose,ref},inProps)),!disableSwipeToOpen&&\"temporary\"===variant&&React.createElement(_NoSsr.default,null,React.createElement(_SwipeArea.default,(0,_extends2.default)({anchor,ref:swipeAreaRef,width:swipeAreaWidth},SwipeAreaProps))))});require.propTypes={anchor:global.default.oneOf([\"left\",\"top\",\"right\",\"bottom\"]),\nchildren:global.default.node,disableBackdropTransition:global.default.bool,disableDiscovery:global.default.bool,disableSwipeToOpen:global.default.bool,hideBackdrop:global.default.bool,hysteresis:global.default.number,minFlingVelocity:global.default.number,ModalProps:global.default.shape({BackdropProps:global.default.shape({component:module.elementTypeAcceptingRef})}),onClose:global.default.func.isRequired,onOpen:global.default.func.isRequired,open:global.default.bool.isRequired,PaperProps:global.default.shape({component:module.elementTypeAcceptingRef,\nstyle:global.default.object}),SwipeAreaProps:global.default.object,swipeAreaWidth:global.default.number,transitionDuration:global.default.oneOfType([global.default.number,global.default.shape({enter:global.default.number,exit:global.default.number})]),variant:global.default.oneOf([\"permanent\",\"persistent\",\"temporary\"])};exports.default=require}","~:source","shadow$provide[\"module$node_modules$$material_ui$core$SwipeableDrawer$SwipeableDrawer\"] = function(global,require,module,exports) {\n\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.reset = reset;\nexports.default = void 0;\n\nvar _objectWithoutProperties2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectWithoutProperties\"));\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar React = _interopRequireWildcard(require(\"react\"));\n\nvar _propTypes = _interopRequireDefault(require(\"prop-types\"));\n\nvar ReactDOM = _interopRequireWildcard(require(\"react-dom\"));\n\nvar _utils = require(\"@material-ui/utils\");\n\nvar _styles = require(\"@material-ui/styles\");\n\nvar _Drawer = _interopRequireWildcard(require(\"../Drawer/Drawer\"));\n\nvar _ownerDocument = _interopRequireDefault(require(\"../utils/ownerDocument\"));\n\nvar _useEventCallback = _interopRequireDefault(require(\"../utils/useEventCallback\"));\n\nvar _transitions = require(\"../styles/transitions\");\n\nvar _useTheme = _interopRequireDefault(require(\"../styles/useTheme\"));\n\nvar _utils2 = require(\"../transitions/utils\");\n\nvar _NoSsr = _interopRequireDefault(require(\"../NoSsr\"));\n\nvar _SwipeArea = _interopRequireDefault(require(\"./SwipeArea\"));\n\n// This value is closed to what browsers are using internally to\n// trigger a native scroll.\nvar UNCERTAINTY_THRESHOLD = 3; // px\n// We can only have one node at the time claiming ownership for handling the swipe.\n// Otherwise, the UX would be confusing.\n// That's why we use a singleton here.\n\nvar nodeThatClaimedTheSwipe = null; // Exported for test purposes.\n\nfunction reset() {\n  nodeThatClaimedTheSwipe = null;\n}\n\nfunction calculateCurrentX(anchor, touches) {\n  return anchor === 'right' ? document.body.offsetWidth - touches[0].pageX : touches[0].pageX;\n}\n\nfunction calculateCurrentY(anchor, touches) {\n  return anchor === 'bottom' ? window.innerHeight - touches[0].clientY : touches[0].clientY;\n}\n\nfunction getMaxTranslate(horizontalSwipe, paperInstance) {\n  return horizontalSwipe ? paperInstance.clientWidth : paperInstance.clientHeight;\n}\n\nfunction getTranslate(currentTranslate, startLocation, open, maxTranslate) {\n  return Math.min(Math.max(open ? startLocation - currentTranslate : maxTranslate + startLocation - currentTranslate, 0), maxTranslate);\n}\n\nfunction getDomTreeShapes(element, rootNode) {\n  // Adapted from https://github.com/oliviertassinari/react-swipeable-views/blob/7666de1dba253b896911adf2790ce51467670856/packages/react-swipeable-views/src/SwipeableViews.js#L129\n  var domTreeShapes = [];\n\n  while (element && element !== rootNode) {\n    var style = window.getComputedStyle(element);\n\n    if ( // Ignore the scroll children if the element is absolute positioned.\n    style.getPropertyValue('position') === 'absolute' || // Ignore the scroll children if the element has an overflowX hidden\n    style.getPropertyValue('overflow-x') === 'hidden') {\n      domTreeShapes = [];\n    } else if (element.clientWidth > 0 && element.scrollWidth > element.clientWidth || element.clientHeight > 0 && element.scrollHeight > element.clientHeight) {\n      // Ignore the nodes that have no width.\n      // Keep elements with a scroll\n      domTreeShapes.push(element);\n    }\n\n    element = element.parentElement;\n  }\n\n  return domTreeShapes;\n}\n\nfunction findNativeHandler(_ref) {\n  var domTreeShapes = _ref.domTreeShapes,\n      start = _ref.start,\n      current = _ref.current,\n      anchor = _ref.anchor;\n  // Adapted from https://github.com/oliviertassinari/react-swipeable-views/blob/7666de1dba253b896911adf2790ce51467670856/packages/react-swipeable-views/src/SwipeableViews.js#L175\n  var axisProperties = {\n    scrollPosition: {\n      x: 'scrollLeft',\n      y: 'scrollTop'\n    },\n    scrollLength: {\n      x: 'scrollWidth',\n      y: 'scrollHeight'\n    },\n    clientLength: {\n      x: 'clientWidth',\n      y: 'clientHeight'\n    }\n  };\n  return domTreeShapes.some(function (shape) {\n    // Determine if we are going backward or forward.\n    var goingForward = current >= start;\n\n    if (anchor === 'top' || anchor === 'left') {\n      goingForward = !goingForward;\n    }\n\n    var axis = anchor === 'left' || anchor === 'right' ? 'x' : 'y';\n    var scrollPosition = shape[axisProperties.scrollPosition[axis]];\n    var areNotAtStart = scrollPosition > 0;\n    var areNotAtEnd = scrollPosition + shape[axisProperties.clientLength[axis]] < shape[axisProperties.scrollLength[axis]];\n\n    if (goingForward && areNotAtEnd || !goingForward && areNotAtStart) {\n      return shape;\n    }\n\n    return null;\n  });\n}\n\nvar iOS = typeof navigator !== 'undefined' && /iPad|iPhone|iPod/.test(navigator.userAgent);\nvar transitionDurationDefault = {\n  enter: _transitions.duration.enteringScreen,\n  exit: _transitions.duration.leavingScreen\n};\nvar useEnhancedEffect = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;\nvar SwipeableDrawer = /*#__PURE__*/React.forwardRef(function SwipeableDrawer(inProps, ref) {\n  var theme = (0, _useTheme.default)();\n  var props = (0, _styles.getThemeProps)({\n    name: 'MuiSwipeableDrawer',\n    props: (0, _extends2.default)({}, inProps),\n    theme: theme\n  });\n  var _props$anchor = props.anchor,\n      anchor = _props$anchor === void 0 ? 'left' : _props$anchor,\n      _props$disableBackdro = props.disableBackdropTransition,\n      disableBackdropTransition = _props$disableBackdro === void 0 ? false : _props$disableBackdro,\n      _props$disableDiscove = props.disableDiscovery,\n      disableDiscovery = _props$disableDiscove === void 0 ? false : _props$disableDiscove,\n      _props$disableSwipeTo = props.disableSwipeToOpen,\n      disableSwipeToOpen = _props$disableSwipeTo === void 0 ? iOS : _props$disableSwipeTo,\n      hideBackdrop = props.hideBackdrop,\n      _props$hysteresis = props.hysteresis,\n      hysteresis = _props$hysteresis === void 0 ? 0.52 : _props$hysteresis,\n      _props$minFlingVeloci = props.minFlingVelocity,\n      minFlingVelocity = _props$minFlingVeloci === void 0 ? 450 : _props$minFlingVeloci,\n      _props$ModalProps = props.ModalProps;\n  _props$ModalProps = _props$ModalProps === void 0 ? {} : _props$ModalProps;\n  var BackdropProps = _props$ModalProps.BackdropProps,\n      ModalPropsProp = (0, _objectWithoutProperties2.default)(_props$ModalProps, [\"BackdropProps\"]),\n      onClose = props.onClose,\n      onOpen = props.onOpen,\n      open = props.open,\n      _props$PaperProps = props.PaperProps,\n      PaperProps = _props$PaperProps === void 0 ? {} : _props$PaperProps,\n      SwipeAreaProps = props.SwipeAreaProps,\n      _props$swipeAreaWidth = props.swipeAreaWidth,\n      swipeAreaWidth = _props$swipeAreaWidth === void 0 ? 20 : _props$swipeAreaWidth,\n      _props$transitionDura = props.transitionDuration,\n      transitionDuration = _props$transitionDura === void 0 ? transitionDurationDefault : _props$transitionDura,\n      _props$variant = props.variant,\n      variant = _props$variant === void 0 ? 'temporary' : _props$variant,\n      other = (0, _objectWithoutProperties2.default)(props, [\"anchor\", \"disableBackdropTransition\", \"disableDiscovery\", \"disableSwipeToOpen\", \"hideBackdrop\", \"hysteresis\", \"minFlingVelocity\", \"ModalProps\", \"onClose\", \"onOpen\", \"open\", \"PaperProps\", \"SwipeAreaProps\", \"swipeAreaWidth\", \"transitionDuration\", \"variant\"]);\n\n  var _React$useState = React.useState(false),\n      maybeSwiping = _React$useState[0],\n      setMaybeSwiping = _React$useState[1];\n\n  var swipeInstance = React.useRef({\n    isSwiping: null\n  });\n  var swipeAreaRef = React.useRef();\n  var backdropRef = React.useRef();\n  var paperRef = React.useRef();\n  var touchDetected = React.useRef(false); // Ref for transition duration based on / to match swipe speed\n\n  var calculatedDurationRef = React.useRef(); // Use a ref so the open value used is always up to date inside useCallback.\n\n  useEnhancedEffect(function () {\n    calculatedDurationRef.current = null;\n  }, [open]);\n  var setPosition = React.useCallback(function (translate) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _options$mode = options.mode,\n        mode = _options$mode === void 0 ? null : _options$mode,\n        _options$changeTransi = options.changeTransition,\n        changeTransition = _options$changeTransi === void 0 ? true : _options$changeTransi;\n    var anchorRtl = (0, _Drawer.getAnchor)(theme, anchor);\n    var rtlTranslateMultiplier = ['right', 'bottom'].indexOf(anchorRtl) !== -1 ? 1 : -1;\n    var horizontalSwipe = (0, _Drawer.isHorizontal)(anchor);\n    var transform = horizontalSwipe ? \"translate(\".concat(rtlTranslateMultiplier * translate, \"px, 0)\") : \"translate(0, \".concat(rtlTranslateMultiplier * translate, \"px)\");\n    var drawerStyle = paperRef.current.style;\n    drawerStyle.webkitTransform = transform;\n    drawerStyle.transform = transform;\n    var transition = '';\n\n    if (mode) {\n      transition = theme.transitions.create('all', (0, _utils2.getTransitionProps)({\n        timeout: transitionDuration\n      }, {\n        mode: mode\n      }));\n    }\n\n    if (changeTransition) {\n      drawerStyle.webkitTransition = transition;\n      drawerStyle.transition = transition;\n    }\n\n    if (!disableBackdropTransition && !hideBackdrop) {\n      var backdropStyle = backdropRef.current.style;\n      backdropStyle.opacity = 1 - translate / getMaxTranslate(horizontalSwipe, paperRef.current);\n\n      if (changeTransition) {\n        backdropStyle.webkitTransition = transition;\n        backdropStyle.transition = transition;\n      }\n    }\n  }, [anchor, disableBackdropTransition, hideBackdrop, theme, transitionDuration]);\n  var handleBodyTouchEnd = (0, _useEventCallback.default)(function (event) {\n    if (!touchDetected.current) {\n      return;\n    }\n\n    nodeThatClaimedTheSwipe = null;\n    touchDetected.current = false;\n    setMaybeSwiping(false); // The swipe wasn't started.\n\n    if (!swipeInstance.current.isSwiping) {\n      swipeInstance.current.isSwiping = null;\n      return;\n    }\n\n    swipeInstance.current.isSwiping = null;\n    var anchorRtl = (0, _Drawer.getAnchor)(theme, anchor);\n    var horizontal = (0, _Drawer.isHorizontal)(anchor);\n    var current;\n\n    if (horizontal) {\n      current = calculateCurrentX(anchorRtl, event.changedTouches);\n    } else {\n      current = calculateCurrentY(anchorRtl, event.changedTouches);\n    }\n\n    var startLocation = horizontal ? swipeInstance.current.startX : swipeInstance.current.startY;\n    var maxTranslate = getMaxTranslate(horizontal, paperRef.current);\n    var currentTranslate = getTranslate(current, startLocation, open, maxTranslate);\n    var translateRatio = currentTranslate / maxTranslate;\n\n    if (Math.abs(swipeInstance.current.velocity) > minFlingVelocity) {\n      // Calculate transition duration to match swipe speed\n      calculatedDurationRef.current = Math.abs((maxTranslate - currentTranslate) / swipeInstance.current.velocity) * 1000;\n    }\n\n    if (open) {\n      if (swipeInstance.current.velocity > minFlingVelocity || translateRatio > hysteresis) {\n        onClose();\n      } else {\n        // Reset the position, the swipe was aborted.\n        setPosition(0, {\n          mode: 'exit'\n        });\n      }\n\n      return;\n    }\n\n    if (swipeInstance.current.velocity < -minFlingVelocity || 1 - translateRatio > hysteresis) {\n      onOpen();\n    } else {\n      // Reset the position, the swipe was aborted.\n      setPosition(getMaxTranslate(horizontal, paperRef.current), {\n        mode: 'enter'\n      });\n    }\n  });\n  var handleBodyTouchMove = (0, _useEventCallback.default)(function (event) {\n    // the ref may be null when a parent component updates while swiping\n    if (!paperRef.current || !touchDetected.current) {\n      return;\n    } // We are not supposed to handle this touch move because the swipe was started in a scrollable container in the drawer\n\n\n    if (nodeThatClaimedTheSwipe != null && nodeThatClaimedTheSwipe !== swipeInstance.current) {\n      return;\n    }\n\n    var anchorRtl = (0, _Drawer.getAnchor)(theme, anchor);\n    var horizontalSwipe = (0, _Drawer.isHorizontal)(anchor);\n    var currentX = calculateCurrentX(anchorRtl, event.touches);\n    var currentY = calculateCurrentY(anchorRtl, event.touches);\n\n    if (open && paperRef.current.contains(event.target) && nodeThatClaimedTheSwipe == null) {\n      var domTreeShapes = getDomTreeShapes(event.target, paperRef.current);\n      var nativeHandler = findNativeHandler({\n        domTreeShapes: domTreeShapes,\n        start: horizontalSwipe ? swipeInstance.current.startX : swipeInstance.current.startY,\n        current: horizontalSwipe ? currentX : currentY,\n        anchor: anchor\n      });\n\n      if (nativeHandler) {\n        nodeThatClaimedTheSwipe = nativeHandler;\n        return;\n      }\n\n      nodeThatClaimedTheSwipe = swipeInstance.current;\n    } // We don't know yet.\n\n\n    if (swipeInstance.current.isSwiping == null) {\n      var dx = Math.abs(currentX - swipeInstance.current.startX);\n      var dy = Math.abs(currentY - swipeInstance.current.startY); // We are likely to be swiping, let's prevent the scroll event on iOS.\n\n      if (dx > dy) {\n        if (event.cancelable) {\n          event.preventDefault();\n        }\n      }\n\n      var definitelySwiping = horizontalSwipe ? dx > dy && dx > UNCERTAINTY_THRESHOLD : dy > dx && dy > UNCERTAINTY_THRESHOLD;\n\n      if (definitelySwiping === true || (horizontalSwipe ? dy > UNCERTAINTY_THRESHOLD : dx > UNCERTAINTY_THRESHOLD)) {\n        swipeInstance.current.isSwiping = definitelySwiping;\n\n        if (!definitelySwiping) {\n          handleBodyTouchEnd(event);\n          return;\n        } // Shift the starting point.\n\n\n        swipeInstance.current.startX = currentX;\n        swipeInstance.current.startY = currentY; // Compensate for the part of the drawer displayed on touch start.\n\n        if (!disableDiscovery && !open) {\n          if (horizontalSwipe) {\n            swipeInstance.current.startX -= swipeAreaWidth;\n          } else {\n            swipeInstance.current.startY -= swipeAreaWidth;\n          }\n        }\n      }\n    }\n\n    if (!swipeInstance.current.isSwiping) {\n      return;\n    }\n\n    var maxTranslate = getMaxTranslate(horizontalSwipe, paperRef.current);\n    var startLocation = horizontalSwipe ? swipeInstance.current.startX : swipeInstance.current.startY;\n\n    if (open && !swipeInstance.current.paperHit) {\n      startLocation = Math.min(startLocation, maxTranslate);\n    }\n\n    var translate = getTranslate(horizontalSwipe ? currentX : currentY, startLocation, open, maxTranslate);\n\n    if (open) {\n      if (!swipeInstance.current.paperHit) {\n        var paperHit = horizontalSwipe ? currentX < maxTranslate : currentY < maxTranslate;\n\n        if (paperHit) {\n          swipeInstance.current.paperHit = true;\n          swipeInstance.current.startX = currentX;\n          swipeInstance.current.startY = currentY;\n        } else {\n          return;\n        }\n      } else if (translate === 0) {\n        swipeInstance.current.startX = currentX;\n        swipeInstance.current.startY = currentY;\n      }\n    }\n\n    if (swipeInstance.current.lastTranslate === null) {\n      swipeInstance.current.lastTranslate = translate;\n      swipeInstance.current.lastTime = performance.now() + 1;\n    }\n\n    var velocity = (translate - swipeInstance.current.lastTranslate) / (performance.now() - swipeInstance.current.lastTime) * 1e3; // Low Pass filter.\n\n    swipeInstance.current.velocity = swipeInstance.current.velocity * 0.4 + velocity * 0.6;\n    swipeInstance.current.lastTranslate = translate;\n    swipeInstance.current.lastTime = performance.now(); // We are swiping, let's prevent the scroll event on iOS.\n\n    if (event.cancelable) {\n      event.preventDefault();\n    }\n\n    setPosition(translate);\n  });\n  var handleBodyTouchStart = (0, _useEventCallback.default)(function (event) {\n    // We are not supposed to handle this touch move.\n    // Example of use case: ignore the event if there is a Slider.\n    if (event.defaultPrevented) {\n      return;\n    } // We can only have one node at the time claiming ownership for handling the swipe.\n\n\n    if (event.muiHandled) {\n      return;\n    } // At least one element clogs the drawer interaction zone.\n\n\n    if (open && !backdropRef.current.contains(event.target) && !paperRef.current.contains(event.target)) {\n      return;\n    }\n\n    var anchorRtl = (0, _Drawer.getAnchor)(theme, anchor);\n    var horizontalSwipe = (0, _Drawer.isHorizontal)(anchor);\n    var currentX = calculateCurrentX(anchorRtl, event.touches);\n    var currentY = calculateCurrentY(anchorRtl, event.touches);\n\n    if (!open) {\n      if (disableSwipeToOpen || event.target !== swipeAreaRef.current) {\n        return;\n      }\n\n      if (horizontalSwipe) {\n        if (currentX > swipeAreaWidth) {\n          return;\n        }\n      } else if (currentY > swipeAreaWidth) {\n        return;\n      }\n    }\n\n    event.muiHandled = true;\n    nodeThatClaimedTheSwipe = null;\n    swipeInstance.current.startX = currentX;\n    swipeInstance.current.startY = currentY;\n    setMaybeSwiping(true);\n\n    if (!open && paperRef.current) {\n      // The ref may be null when a parent component updates while swiping.\n      setPosition(getMaxTranslate(horizontalSwipe, paperRef.current) + (disableDiscovery ? 20 : -swipeAreaWidth), {\n        changeTransition: false\n      });\n    }\n\n    swipeInstance.current.velocity = 0;\n    swipeInstance.current.lastTime = null;\n    swipeInstance.current.lastTranslate = null;\n    swipeInstance.current.paperHit = false;\n    touchDetected.current = true;\n  });\n  React.useEffect(function () {\n    if (variant === 'temporary') {\n      var doc = (0, _ownerDocument.default)(paperRef.current);\n      doc.addEventListener('touchstart', handleBodyTouchStart);\n      doc.addEventListener('touchmove', handleBodyTouchMove, {\n        passive: false\n      });\n      doc.addEventListener('touchend', handleBodyTouchEnd);\n      return function () {\n        doc.removeEventListener('touchstart', handleBodyTouchStart);\n        doc.removeEventListener('touchmove', handleBodyTouchMove, {\n          passive: false\n        });\n        doc.removeEventListener('touchend', handleBodyTouchEnd);\n      };\n    }\n\n    return undefined;\n  }, [variant, handleBodyTouchStart, handleBodyTouchMove, handleBodyTouchEnd]);\n  React.useEffect(function () {\n    return function () {\n      // We need to release the lock.\n      if (nodeThatClaimedTheSwipe === swipeInstance.current) {\n        nodeThatClaimedTheSwipe = null;\n      }\n    };\n  }, []);\n  React.useEffect(function () {\n    if (!open) {\n      setMaybeSwiping(false);\n    }\n  }, [open]);\n  var handleBackdropRef = React.useCallback(function (instance) {\n    // #StrictMode ready\n    backdropRef.current = ReactDOM.findDOMNode(instance);\n  }, []);\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(_Drawer.default, (0, _extends2.default)({\n    open: variant === 'temporary' && maybeSwiping ? true : open,\n    variant: variant,\n    ModalProps: (0, _extends2.default)({\n      BackdropProps: (0, _extends2.default)({}, BackdropProps, {\n        ref: handleBackdropRef\n      })\n    }, ModalPropsProp),\n    PaperProps: (0, _extends2.default)({}, PaperProps, {\n      style: (0, _extends2.default)({\n        pointerEvents: variant === 'temporary' && !open ? 'none' : ''\n      }, PaperProps.style),\n      ref: paperRef\n    }),\n    anchor: anchor,\n    transitionDuration: calculatedDurationRef.current || transitionDuration,\n    onClose: onClose,\n    ref: ref\n  }, other)), !disableSwipeToOpen && variant === 'temporary' && /*#__PURE__*/React.createElement(_NoSsr.default, null, /*#__PURE__*/React.createElement(_SwipeArea.default, (0, _extends2.default)({\n    anchor: anchor,\n    ref: swipeAreaRef,\n    width: swipeAreaWidth\n  }, SwipeAreaProps))));\n});\nprocess.env.NODE_ENV !== \"production\" ? SwipeableDrawer.propTypes = {\n  /**\n   * @ignore\n   */\n  anchor: _propTypes.default.oneOf(['left', 'top', 'right', 'bottom']),\n\n  /**\n   * The content of the component.\n   */\n  children: _propTypes.default.node,\n\n  /**\n   * Disable the backdrop transition.\n   * This can improve the FPS on low-end devices.\n   */\n  disableBackdropTransition: _propTypes.default.bool,\n\n  /**\n   * If `true`, touching the screen near the edge of the drawer will not slide in the drawer a bit\n   * to promote accidental discovery of the swipe gesture.\n   */\n  disableDiscovery: _propTypes.default.bool,\n\n  /**\n   * If `true`, swipe to open is disabled. This is useful in browsers where swiping triggers\n   * navigation actions. Swipe to open is disabled on iOS browsers by default.\n   */\n  disableSwipeToOpen: _propTypes.default.bool,\n\n  /**\n   * @ignore\n   */\n  hideBackdrop: _propTypes.default.bool,\n\n  /**\n   * Affects how far the drawer must be opened/closed to change his state.\n   * Specified as percent (0-1) of the width of the drawer\n   */\n  hysteresis: _propTypes.default.number,\n\n  /**\n   * Defines, from which (average) velocity on, the swipe is\n   * defined as complete although hysteresis isn't reached.\n   * Good threshold is between 250 - 1000 px/s\n   */\n  minFlingVelocity: _propTypes.default.number,\n\n  /**\n   * @ignore\n   */\n  ModalProps: _propTypes.default.shape({\n    BackdropProps: _propTypes.default.shape({\n      component: _utils.elementTypeAcceptingRef\n    })\n  }),\n\n  /**\n   * Callback fired when the component requests to be closed.\n   *\n   * @param {object} event The event source of the callback.\n   */\n  onClose: _propTypes.default.func.isRequired,\n\n  /**\n   * Callback fired when the component requests to be opened.\n   *\n   * @param {object} event The event source of the callback.\n   */\n  onOpen: _propTypes.default.func.isRequired,\n\n  /**\n   * If `true`, the drawer is open.\n   */\n  open: _propTypes.default.bool.isRequired,\n\n  /**\n   * @ignore\n   */\n  PaperProps: _propTypes.default.shape({\n    component: _utils.elementTypeAcceptingRef,\n    style: _propTypes.default.object\n  }),\n\n  /**\n   * The element is used to intercept the touch events on the edge.\n   */\n  SwipeAreaProps: _propTypes.default.object,\n\n  /**\n   * The width of the left most (or right most) area in pixels where the\n   * drawer can be swiped open from.\n   */\n  swipeAreaWidth: _propTypes.default.number,\n\n  /**\n   * The duration for the transition, in milliseconds.\n   * You may specify a single timeout for all transitions, or individually with an object.\n   */\n  transitionDuration: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.shape({\n    enter: _propTypes.default.number,\n    exit: _propTypes.default.number\n  })]),\n\n  /**\n   * @ignore\n   */\n  variant: _propTypes.default.oneOf(['permanent', 'persistent', 'temporary'])\n} : void 0;\nvar _default = SwipeableDrawer;\nexports.default = _default;\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$$material_ui$core$transitions$utils","~$module$node_modules$$material_ui$core$styles$transitions","~$module$node_modules$$babel$runtime$helpers$interopRequireWildcard","~$module$node_modules$$babel$runtime$helpers$interopRequireDefault","~$module$node_modules$react_dom$index","~$module$node_modules$$material_ui$core$styles$useTheme","~$module$node_modules$react$index","~$module$node_modules$$material_ui$core$SwipeableDrawer$SwipeArea","~$module$node_modules$prop_types$index","~$module$node_modules$$material_ui$core$utils$useEventCallback","~$shadow.js","~$module$node_modules$$material_ui$core$Drawer$Drawer","~$module$node_modules$$babel$runtime$helpers$extends","~$module$node_modules$$material_ui$styles$index","~$module$node_modules$$babel$runtime$helpers$objectWithoutProperties","~$module$node_modules$$material_ui$core$utils$ownerDocument","~$module$node_modules$$material_ui$core$NoSsr$index","~$module$node_modules$$material_ui$utils$index"]],"~:properties",["^5",["disableDiscovery","width","ModalProps","passive","SwipeAreaProps","onClose","webkitTransition","hysteresis","lastTranslate","disableSwipeToOpen","children","component","x","__esModule","transform","PaperProps","reset","startY","propTypes","anchor","mode","name","startX","style","value","BackdropProps","timeout","swipeAreaWidth","start","isSwiping","hideBackdrop","current","paperHit","minFlingVelocity","props","disableBackdropTransition","webkitTransform","y","ref","exit","theme","open","transition","transitionDuration","enter","default","opacity","changeTransition","domTreeShapes","variant","pointerEvents","lastTime","velocity","muiHandled","onOpen"]],"~:compiled-at",1622892592325,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$$material_ui$core$SwipeableDrawer$SwipeableDrawer.js\",\n\"lineCount\":29,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/@material-ui/core/SwipeableDrawer/SwipeableDrawer.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$$material_ui$core$SwipeableDrawer$SwipeableDrawer\\\"] = function(global,require,module,exports) {\\n\\\"use strict\\\";\\n\\nvar _interopRequireWildcard = require(\\\"@babel/runtime/helpers/interopRequireWildcard\\\");\\n\\nvar _interopRequireDefault = require(\\\"@babel/runtime/helpers/interopRequireDefault\\\");\\n\\nObject.defineProperty(exports, \\\"__esModule\\\", {\\n  value: true\\n});\\nexports.reset = reset;\\nexports.default = void 0;\\n\\nvar _objectWithoutProperties2 = _interopRequireDefault(require(\\\"@babel/runtime/helpers/objectWithoutProperties\\\"));\\n\\nvar _extends2 = _interopRequireDefault(require(\\\"@babel/runtime/helpers/extends\\\"));\\n\\nvar React = _interopRequireWildcard(require(\\\"react\\\"));\\n\\nvar _propTypes = _interopRequireDefault(require(\\\"prop-types\\\"));\\n\\nvar ReactDOM = _interopRequireWildcard(require(\\\"react-dom\\\"));\\n\\nvar _utils = require(\\\"@material-ui/utils\\\");\\n\\nvar _styles = require(\\\"@material-ui/styles\\\");\\n\\nvar _Drawer = _interopRequireWildcard(require(\\\"../Drawer/Drawer\\\"));\\n\\nvar _ownerDocument = _interopRequireDefault(require(\\\"../utils/ownerDocument\\\"));\\n\\nvar _useEventCallback = _interopRequireDefault(require(\\\"../utils/useEventCallback\\\"));\\n\\nvar _transitions = require(\\\"../styles/transitions\\\");\\n\\nvar _useTheme = _interopRequireDefault(require(\\\"../styles/useTheme\\\"));\\n\\nvar _utils2 = require(\\\"../transitions/utils\\\");\\n\\nvar _NoSsr = _interopRequireDefault(require(\\\"../NoSsr\\\"));\\n\\nvar _SwipeArea = _interopRequireDefault(require(\\\"./SwipeArea\\\"));\\n\\n// This value is closed to what browsers are using internally to\\n// trigger a native scroll.\\nvar UNCERTAINTY_THRESHOLD = 3; // px\\n// We can only have one node at the time claiming ownership for handling the swipe.\\n// Otherwise, the UX would be confusing.\\n// That's why we use a singleton here.\\n\\nvar nodeThatClaimedTheSwipe = null; // Exported for test purposes.\\n\\nfunction reset() {\\n  nodeThatClaimedTheSwipe = null;\\n}\\n\\nfunction calculateCurrentX(anchor, touches) {\\n  return anchor === 'right' ? document.body.offsetWidth - touches[0].pageX : touches[0].pageX;\\n}\\n\\nfunction calculateCurrentY(anchor, touches) {\\n  return anchor === 'bottom' ? window.innerHeight - touches[0].clientY : touches[0].clientY;\\n}\\n\\nfunction getMaxTranslate(horizontalSwipe, paperInstance) {\\n  return horizontalSwipe ? paperInstance.clientWidth : paperInstance.clientHeight;\\n}\\n\\nfunction getTranslate(currentTranslate, startLocation, open, maxTranslate) {\\n  return Math.min(Math.max(open ? startLocation - currentTranslate : maxTranslate + startLocation - currentTranslate, 0), maxTranslate);\\n}\\n\\nfunction getDomTreeShapes(element, rootNode) {\\n  // Adapted from https://github.com/oliviertassinari/react-swipeable-views/blob/7666de1dba253b896911adf2790ce51467670856/packages/react-swipeable-views/src/SwipeableViews.js#L129\\n  var domTreeShapes = [];\\n\\n  while (element && element !== rootNode) {\\n    var style = window.getComputedStyle(element);\\n\\n    if ( // Ignore the scroll children if the element is absolute positioned.\\n    style.getPropertyValue('position') === 'absolute' || // Ignore the scroll children if the element has an overflowX hidden\\n    style.getPropertyValue('overflow-x') === 'hidden') {\\n      domTreeShapes = [];\\n    } else if (element.clientWidth > 0 && element.scrollWidth > element.clientWidth || element.clientHeight > 0 && element.scrollHeight > element.clientHeight) {\\n      // Ignore the nodes that have no width.\\n      // Keep elements with a scroll\\n      domTreeShapes.push(element);\\n    }\\n\\n    element = element.parentElement;\\n  }\\n\\n  return domTreeShapes;\\n}\\n\\nfunction findNativeHandler(_ref) {\\n  var domTreeShapes = _ref.domTreeShapes,\\n      start = _ref.start,\\n      current = _ref.current,\\n      anchor = _ref.anchor;\\n  // Adapted from https://github.com/oliviertassinari/react-swipeable-views/blob/7666de1dba253b896911adf2790ce51467670856/packages/react-swipeable-views/src/SwipeableViews.js#L175\\n  var axisProperties = {\\n    scrollPosition: {\\n      x: 'scrollLeft',\\n      y: 'scrollTop'\\n    },\\n    scrollLength: {\\n      x: 'scrollWidth',\\n      y: 'scrollHeight'\\n    },\\n    clientLength: {\\n      x: 'clientWidth',\\n      y: 'clientHeight'\\n    }\\n  };\\n  return domTreeShapes.some(function (shape) {\\n    // Determine if we are going backward or forward.\\n    var goingForward = current >= start;\\n\\n    if (anchor === 'top' || anchor === 'left') {\\n      goingForward = !goingForward;\\n    }\\n\\n    var axis = anchor === 'left' || anchor === 'right' ? 'x' : 'y';\\n    var scrollPosition = shape[axisProperties.scrollPosition[axis]];\\n    var areNotAtStart = scrollPosition > 0;\\n    var areNotAtEnd = scrollPosition + shape[axisProperties.clientLength[axis]] < shape[axisProperties.scrollLength[axis]];\\n\\n    if (goingForward && areNotAtEnd || !goingForward && areNotAtStart) {\\n      return shape;\\n    }\\n\\n    return null;\\n  });\\n}\\n\\nvar iOS = typeof navigator !== 'undefined' && /iPad|iPhone|iPod/.test(navigator.userAgent);\\nvar transitionDurationDefault = {\\n  enter: _transitions.duration.enteringScreen,\\n  exit: _transitions.duration.leavingScreen\\n};\\nvar useEnhancedEffect = typeof window !== 'undefined' ? React.useLayoutEffect : React.useEffect;\\nvar SwipeableDrawer = /*#__PURE__*/React.forwardRef(function SwipeableDrawer(inProps, ref) {\\n  var theme = (0, _useTheme.default)();\\n  var props = (0, _styles.getThemeProps)({\\n    name: 'MuiSwipeableDrawer',\\n    props: (0, _extends2.default)({}, inProps),\\n    theme: theme\\n  });\\n  var _props$anchor = props.anchor,\\n      anchor = _props$anchor === void 0 ? 'left' : _props$anchor,\\n      _props$disableBackdro = props.disableBackdropTransition,\\n      disableBackdropTransition = _props$disableBackdro === void 0 ? false : _props$disableBackdro,\\n      _props$disableDiscove = props.disableDiscovery,\\n      disableDiscovery = _props$disableDiscove === void 0 ? false : _props$disableDiscove,\\n      _props$disableSwipeTo = props.disableSwipeToOpen,\\n      disableSwipeToOpen = _props$disableSwipeTo === void 0 ? iOS : _props$disableSwipeTo,\\n      hideBackdrop = props.hideBackdrop,\\n      _props$hysteresis = props.hysteresis,\\n      hysteresis = _props$hysteresis === void 0 ? 0.52 : _props$hysteresis,\\n      _props$minFlingVeloci = props.minFlingVelocity,\\n      minFlingVelocity = _props$minFlingVeloci === void 0 ? 450 : _props$minFlingVeloci,\\n      _props$ModalProps = props.ModalProps;\\n  _props$ModalProps = _props$ModalProps === void 0 ? {} : _props$ModalProps;\\n  var BackdropProps = _props$ModalProps.BackdropProps,\\n      ModalPropsProp = (0, _objectWithoutProperties2.default)(_props$ModalProps, [\\\"BackdropProps\\\"]),\\n      onClose = props.onClose,\\n      onOpen = props.onOpen,\\n      open = props.open,\\n      _props$PaperProps = props.PaperProps,\\n      PaperProps = _props$PaperProps === void 0 ? {} : _props$PaperProps,\\n      SwipeAreaProps = props.SwipeAreaProps,\\n      _props$swipeAreaWidth = props.swipeAreaWidth,\\n      swipeAreaWidth = _props$swipeAreaWidth === void 0 ? 20 : _props$swipeAreaWidth,\\n      _props$transitionDura = props.transitionDuration,\\n      transitionDuration = _props$transitionDura === void 0 ? transitionDurationDefault : _props$transitionDura,\\n      _props$variant = props.variant,\\n      variant = _props$variant === void 0 ? 'temporary' : _props$variant,\\n      other = (0, _objectWithoutProperties2.default)(props, [\\\"anchor\\\", \\\"disableBackdropTransition\\\", \\\"disableDiscovery\\\", \\\"disableSwipeToOpen\\\", \\\"hideBackdrop\\\", \\\"hysteresis\\\", \\\"minFlingVelocity\\\", \\\"ModalProps\\\", \\\"onClose\\\", \\\"onOpen\\\", \\\"open\\\", \\\"PaperProps\\\", \\\"SwipeAreaProps\\\", \\\"swipeAreaWidth\\\", \\\"transitionDuration\\\", \\\"variant\\\"]);\\n\\n  var _React$useState = React.useState(false),\\n      maybeSwiping = _React$useState[0],\\n      setMaybeSwiping = _React$useState[1];\\n\\n  var swipeInstance = React.useRef({\\n    isSwiping: null\\n  });\\n  var swipeAreaRef = React.useRef();\\n  var backdropRef = React.useRef();\\n  var paperRef = React.useRef();\\n  var touchDetected = React.useRef(false); // Ref for transition duration based on / to match swipe speed\\n\\n  var calculatedDurationRef = React.useRef(); // Use a ref so the open value used is always up to date inside useCallback.\\n\\n  useEnhancedEffect(function () {\\n    calculatedDurationRef.current = null;\\n  }, [open]);\\n  var setPosition = React.useCallback(function (translate) {\\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\\n    var _options$mode = options.mode,\\n        mode = _options$mode === void 0 ? null : _options$mode,\\n        _options$changeTransi = options.changeTransition,\\n        changeTransition = _options$changeTransi === void 0 ? true : _options$changeTransi;\\n    var anchorRtl = (0, _Drawer.getAnchor)(theme, anchor);\\n    var rtlTranslateMultiplier = ['right', 'bottom'].indexOf(anchorRtl) !== -1 ? 1 : -1;\\n    var horizontalSwipe = (0, _Drawer.isHorizontal)(anchor);\\n    var transform = horizontalSwipe ? \\\"translate(\\\".concat(rtlTranslateMultiplier * translate, \\\"px, 0)\\\") : \\\"translate(0, \\\".concat(rtlTranslateMultiplier * translate, \\\"px)\\\");\\n    var drawerStyle = paperRef.current.style;\\n    drawerStyle.webkitTransform = transform;\\n    drawerStyle.transform = transform;\\n    var transition = '';\\n\\n    if (mode) {\\n      transition = theme.transitions.create('all', (0, _utils2.getTransitionProps)({\\n        timeout: transitionDuration\\n      }, {\\n        mode: mode\\n      }));\\n    }\\n\\n    if (changeTransition) {\\n      drawerStyle.webkitTransition = transition;\\n      drawerStyle.transition = transition;\\n    }\\n\\n    if (!disableBackdropTransition && !hideBackdrop) {\\n      var backdropStyle = backdropRef.current.style;\\n      backdropStyle.opacity = 1 - translate / getMaxTranslate(horizontalSwipe, paperRef.current);\\n\\n      if (changeTransition) {\\n        backdropStyle.webkitTransition = transition;\\n        backdropStyle.transition = transition;\\n      }\\n    }\\n  }, [anchor, disableBackdropTransition, hideBackdrop, theme, transitionDuration]);\\n  var handleBodyTouchEnd = (0, _useEventCallback.default)(function (event) {\\n    if (!touchDetected.current) {\\n      return;\\n    }\\n\\n    nodeThatClaimedTheSwipe = null;\\n    touchDetected.current = false;\\n    setMaybeSwiping(false); // The swipe wasn't started.\\n\\n    if (!swipeInstance.current.isSwiping) {\\n      swipeInstance.current.isSwiping = null;\\n      return;\\n    }\\n\\n    swipeInstance.current.isSwiping = null;\\n    var anchorRtl = (0, _Drawer.getAnchor)(theme, anchor);\\n    var horizontal = (0, _Drawer.isHorizontal)(anchor);\\n    var current;\\n\\n    if (horizontal) {\\n      current = calculateCurrentX(anchorRtl, event.changedTouches);\\n    } else {\\n      current = calculateCurrentY(anchorRtl, event.changedTouches);\\n    }\\n\\n    var startLocation = horizontal ? swipeInstance.current.startX : swipeInstance.current.startY;\\n    var maxTranslate = getMaxTranslate(horizontal, paperRef.current);\\n    var currentTranslate = getTranslate(current, startLocation, open, maxTranslate);\\n    var translateRatio = currentTranslate / maxTranslate;\\n\\n    if (Math.abs(swipeInstance.current.velocity) > minFlingVelocity) {\\n      // Calculate transition duration to match swipe speed\\n      calculatedDurationRef.current = Math.abs((maxTranslate - currentTranslate) / swipeInstance.current.velocity) * 1000;\\n    }\\n\\n    if (open) {\\n      if (swipeInstance.current.velocity > minFlingVelocity || translateRatio > hysteresis) {\\n        onClose();\\n      } else {\\n        // Reset the position, the swipe was aborted.\\n        setPosition(0, {\\n          mode: 'exit'\\n        });\\n      }\\n\\n      return;\\n    }\\n\\n    if (swipeInstance.current.velocity < -minFlingVelocity || 1 - translateRatio > hysteresis) {\\n      onOpen();\\n    } else {\\n      // Reset the position, the swipe was aborted.\\n      setPosition(getMaxTranslate(horizontal, paperRef.current), {\\n        mode: 'enter'\\n      });\\n    }\\n  });\\n  var handleBodyTouchMove = (0, _useEventCallback.default)(function (event) {\\n    // the ref may be null when a parent component updates while swiping\\n    if (!paperRef.current || !touchDetected.current) {\\n      return;\\n    } // We are not supposed to handle this touch move because the swipe was started in a scrollable container in the drawer\\n\\n\\n    if (nodeThatClaimedTheSwipe != null && nodeThatClaimedTheSwipe !== swipeInstance.current) {\\n      return;\\n    }\\n\\n    var anchorRtl = (0, _Drawer.getAnchor)(theme, anchor);\\n    var horizontalSwipe = (0, _Drawer.isHorizontal)(anchor);\\n    var currentX = calculateCurrentX(anchorRtl, event.touches);\\n    var currentY = calculateCurrentY(anchorRtl, event.touches);\\n\\n    if (open && paperRef.current.contains(event.target) && nodeThatClaimedTheSwipe == null) {\\n      var domTreeShapes = getDomTreeShapes(event.target, paperRef.current);\\n      var nativeHandler = findNativeHandler({\\n        domTreeShapes: domTreeShapes,\\n        start: horizontalSwipe ? swipeInstance.current.startX : swipeInstance.current.startY,\\n        current: horizontalSwipe ? currentX : currentY,\\n        anchor: anchor\\n      });\\n\\n      if (nativeHandler) {\\n        nodeThatClaimedTheSwipe = nativeHandler;\\n        return;\\n      }\\n\\n      nodeThatClaimedTheSwipe = swipeInstance.current;\\n    } // We don't know yet.\\n\\n\\n    if (swipeInstance.current.isSwiping == null) {\\n      var dx = Math.abs(currentX - swipeInstance.current.startX);\\n      var dy = Math.abs(currentY - swipeInstance.current.startY); // We are likely to be swiping, let's prevent the scroll event on iOS.\\n\\n      if (dx > dy) {\\n        if (event.cancelable) {\\n          event.preventDefault();\\n        }\\n      }\\n\\n      var definitelySwiping = horizontalSwipe ? dx > dy && dx > UNCERTAINTY_THRESHOLD : dy > dx && dy > UNCERTAINTY_THRESHOLD;\\n\\n      if (definitelySwiping === true || (horizontalSwipe ? dy > UNCERTAINTY_THRESHOLD : dx > UNCERTAINTY_THRESHOLD)) {\\n        swipeInstance.current.isSwiping = definitelySwiping;\\n\\n        if (!definitelySwiping) {\\n          handleBodyTouchEnd(event);\\n          return;\\n        } // Shift the starting point.\\n\\n\\n        swipeInstance.current.startX = currentX;\\n        swipeInstance.current.startY = currentY; // Compensate for the part of the drawer displayed on touch start.\\n\\n        if (!disableDiscovery && !open) {\\n          if (horizontalSwipe) {\\n            swipeInstance.current.startX -= swipeAreaWidth;\\n          } else {\\n            swipeInstance.current.startY -= swipeAreaWidth;\\n          }\\n        }\\n      }\\n    }\\n\\n    if (!swipeInstance.current.isSwiping) {\\n      return;\\n    }\\n\\n    var maxTranslate = getMaxTranslate(horizontalSwipe, paperRef.current);\\n    var startLocation = horizontalSwipe ? swipeInstance.current.startX : swipeInstance.current.startY;\\n\\n    if (open && !swipeInstance.current.paperHit) {\\n      startLocation = Math.min(startLocation, maxTranslate);\\n    }\\n\\n    var translate = getTranslate(horizontalSwipe ? currentX : currentY, startLocation, open, maxTranslate);\\n\\n    if (open) {\\n      if (!swipeInstance.current.paperHit) {\\n        var paperHit = horizontalSwipe ? currentX < maxTranslate : currentY < maxTranslate;\\n\\n        if (paperHit) {\\n          swipeInstance.current.paperHit = true;\\n          swipeInstance.current.startX = currentX;\\n          swipeInstance.current.startY = currentY;\\n        } else {\\n          return;\\n        }\\n      } else if (translate === 0) {\\n        swipeInstance.current.startX = currentX;\\n        swipeInstance.current.startY = currentY;\\n      }\\n    }\\n\\n    if (swipeInstance.current.lastTranslate === null) {\\n      swipeInstance.current.lastTranslate = translate;\\n      swipeInstance.current.lastTime = performance.now() + 1;\\n    }\\n\\n    var velocity = (translate - swipeInstance.current.lastTranslate) / (performance.now() - swipeInstance.current.lastTime) * 1e3; // Low Pass filter.\\n\\n    swipeInstance.current.velocity = swipeInstance.current.velocity * 0.4 + velocity * 0.6;\\n    swipeInstance.current.lastTranslate = translate;\\n    swipeInstance.current.lastTime = performance.now(); // We are swiping, let's prevent the scroll event on iOS.\\n\\n    if (event.cancelable) {\\n      event.preventDefault();\\n    }\\n\\n    setPosition(translate);\\n  });\\n  var handleBodyTouchStart = (0, _useEventCallback.default)(function (event) {\\n    // We are not supposed to handle this touch move.\\n    // Example of use case: ignore the event if there is a Slider.\\n    if (event.defaultPrevented) {\\n      return;\\n    } // We can only have one node at the time claiming ownership for handling the swipe.\\n\\n\\n    if (event.muiHandled) {\\n      return;\\n    } // At least one element clogs the drawer interaction zone.\\n\\n\\n    if (open && !backdropRef.current.contains(event.target) && !paperRef.current.contains(event.target)) {\\n      return;\\n    }\\n\\n    var anchorRtl = (0, _Drawer.getAnchor)(theme, anchor);\\n    var horizontalSwipe = (0, _Drawer.isHorizontal)(anchor);\\n    var currentX = calculateCurrentX(anchorRtl, event.touches);\\n    var currentY = calculateCurrentY(anchorRtl, event.touches);\\n\\n    if (!open) {\\n      if (disableSwipeToOpen || event.target !== swipeAreaRef.current) {\\n        return;\\n      }\\n\\n      if (horizontalSwipe) {\\n        if (currentX > swipeAreaWidth) {\\n          return;\\n        }\\n      } else if (currentY > swipeAreaWidth) {\\n        return;\\n      }\\n    }\\n\\n    event.muiHandled = true;\\n    nodeThatClaimedTheSwipe = null;\\n    swipeInstance.current.startX = currentX;\\n    swipeInstance.current.startY = currentY;\\n    setMaybeSwiping(true);\\n\\n    if (!open && paperRef.current) {\\n      // The ref may be null when a parent component updates while swiping.\\n      setPosition(getMaxTranslate(horizontalSwipe, paperRef.current) + (disableDiscovery ? 20 : -swipeAreaWidth), {\\n        changeTransition: false\\n      });\\n    }\\n\\n    swipeInstance.current.velocity = 0;\\n    swipeInstance.current.lastTime = null;\\n    swipeInstance.current.lastTranslate = null;\\n    swipeInstance.current.paperHit = false;\\n    touchDetected.current = true;\\n  });\\n  React.useEffect(function () {\\n    if (variant === 'temporary') {\\n      var doc = (0, _ownerDocument.default)(paperRef.current);\\n      doc.addEventListener('touchstart', handleBodyTouchStart);\\n      doc.addEventListener('touchmove', handleBodyTouchMove, {\\n        passive: false\\n      });\\n      doc.addEventListener('touchend', handleBodyTouchEnd);\\n      return function () {\\n        doc.removeEventListener('touchstart', handleBodyTouchStart);\\n        doc.removeEventListener('touchmove', handleBodyTouchMove, {\\n          passive: false\\n        });\\n        doc.removeEventListener('touchend', handleBodyTouchEnd);\\n      };\\n    }\\n\\n    return undefined;\\n  }, [variant, handleBodyTouchStart, handleBodyTouchMove, handleBodyTouchEnd]);\\n  React.useEffect(function () {\\n    return function () {\\n      // We need to release the lock.\\n      if (nodeThatClaimedTheSwipe === swipeInstance.current) {\\n        nodeThatClaimedTheSwipe = null;\\n      }\\n    };\\n  }, []);\\n  React.useEffect(function () {\\n    if (!open) {\\n      setMaybeSwiping(false);\\n    }\\n  }, [open]);\\n  var handleBackdropRef = React.useCallback(function (instance) {\\n    // #StrictMode ready\\n    backdropRef.current = ReactDOM.findDOMNode(instance);\\n  }, []);\\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(_Drawer.default, (0, _extends2.default)({\\n    open: variant === 'temporary' && maybeSwiping ? true : open,\\n    variant: variant,\\n    ModalProps: (0, _extends2.default)({\\n      BackdropProps: (0, _extends2.default)({}, BackdropProps, {\\n        ref: handleBackdropRef\\n      })\\n    }, ModalPropsProp),\\n    PaperProps: (0, _extends2.default)({}, PaperProps, {\\n      style: (0, _extends2.default)({\\n        pointerEvents: variant === 'temporary' && !open ? 'none' : ''\\n      }, PaperProps.style),\\n      ref: paperRef\\n    }),\\n    anchor: anchor,\\n    transitionDuration: calculatedDurationRef.current || transitionDuration,\\n    onClose: onClose,\\n    ref: ref\\n  }, other)), !disableSwipeToOpen && variant === 'temporary' && /*#__PURE__*/React.createElement(_NoSsr.default, null, /*#__PURE__*/React.createElement(_SwipeArea.default, (0, _extends2.default)({\\n    anchor: anchor,\\n    ref: swipeAreaRef,\\n    width: swipeAreaWidth\\n  }, SwipeAreaProps))));\\n});\\nprocess.env.NODE_ENV !== \\\"production\\\" ? SwipeableDrawer.propTypes = {\\n  /**\\n   * @ignore\\n   */\\n  anchor: _propTypes.default.oneOf(['left', 'top', 'right', 'bottom']),\\n\\n  /**\\n   * The content of the component.\\n   */\\n  children: _propTypes.default.node,\\n\\n  /**\\n   * Disable the backdrop transition.\\n   * This can improve the FPS on low-end devices.\\n   */\\n  disableBackdropTransition: _propTypes.default.bool,\\n\\n  /**\\n   * If `true`, touching the screen near the edge of the drawer will not slide in the drawer a bit\\n   * to promote accidental discovery of the swipe gesture.\\n   */\\n  disableDiscovery: _propTypes.default.bool,\\n\\n  /**\\n   * If `true`, swipe to open is disabled. This is useful in browsers where swiping triggers\\n   * navigation actions. Swipe to open is disabled on iOS browsers by default.\\n   */\\n  disableSwipeToOpen: _propTypes.default.bool,\\n\\n  /**\\n   * @ignore\\n   */\\n  hideBackdrop: _propTypes.default.bool,\\n\\n  /**\\n   * Affects how far the drawer must be opened/closed to change his state.\\n   * Specified as percent (0-1) of the width of the drawer\\n   */\\n  hysteresis: _propTypes.default.number,\\n\\n  /**\\n   * Defines, from which (average) velocity on, the swipe is\\n   * defined as complete although hysteresis isn't reached.\\n   * Good threshold is between 250 - 1000 px/s\\n   */\\n  minFlingVelocity: _propTypes.default.number,\\n\\n  /**\\n   * @ignore\\n   */\\n  ModalProps: _propTypes.default.shape({\\n    BackdropProps: _propTypes.default.shape({\\n      component: _utils.elementTypeAcceptingRef\\n    })\\n  }),\\n\\n  /**\\n   * Callback fired when the component requests to be closed.\\n   *\\n   * @param {object} event The event source of the callback.\\n   */\\n  onClose: _propTypes.default.func.isRequired,\\n\\n  /**\\n   * Callback fired when the component requests to be opened.\\n   *\\n   * @param {object} event The event source of the callback.\\n   */\\n  onOpen: _propTypes.default.func.isRequired,\\n\\n  /**\\n   * If `true`, the drawer is open.\\n   */\\n  open: _propTypes.default.bool.isRequired,\\n\\n  /**\\n   * @ignore\\n   */\\n  PaperProps: _propTypes.default.shape({\\n    component: _utils.elementTypeAcceptingRef,\\n    style: _propTypes.default.object\\n  }),\\n\\n  /**\\n   * The element is used to intercept the touch events on the edge.\\n   */\\n  SwipeAreaProps: _propTypes.default.object,\\n\\n  /**\\n   * The width of the left most (or right most) area in pixels where the\\n   * drawer can be swiped open from.\\n   */\\n  swipeAreaWidth: _propTypes.default.number,\\n\\n  /**\\n   * The duration for the transition, in milliseconds.\\n   * You may specify a single timeout for all transitions, or individually with an object.\\n   */\\n  transitionDuration: _propTypes.default.oneOfType([_propTypes.default.number, _propTypes.default.shape({\\n    enter: _propTypes.default.number,\\n    exit: _propTypes.default.number\\n  })]),\\n\\n  /**\\n   * @ignore\\n   */\\n  variant: _propTypes.default.oneOf(['permanent', 'persistent', 'temporary'])\\n} : void 0;\\nvar _default = SwipeableDrawer;\\nexports.default = _default;\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"calculateCurrentX\",\"anchor\",\"touches\",\"document\",\"body\",\"offsetWidth\",\"pageX\",\"calculateCurrentY\",\"window\",\"innerHeight\",\"clientY\",\"getMaxTranslate\",\"horizontalSwipe\",\"paperInstance\",\"clientWidth\",\"clientHeight\",\"findNativeHandler\",\"_ref\",\"start\",\"current\",\"x\",\"y\",\"domTreeShapes\",\"some\",\"shape\",\"goingForward\",\"axis\",\"scrollPosition\",\"areNotAtEnd\",\"clientLength\",\"scrollLength\",\"_interopRequireWildcard\",\"_interopRequireDefault\",\"Object\",\"defineProperty\",\"value\",\"reset\",\"nodeThatClaimedTheSwipe\",\"default\",\"_objectWithoutProperties2\",\"_extends2\",\"React\",\"_propTypes\",\"ReactDOM\",\"_utils\",\"_styles\",\"_Drawer\",\"_ownerDocument\",\"_useEventCallback\",\"_transitions\",\"_useTheme\",\"_utils2\",\"_NoSsr\",\"_SwipeArea\",\"iOS\",\"navigator\",\"test\",\"userAgent\",\"transitionDurationDefault\",\"enter\",\"duration\",\"enteringScreen\",\"exit\",\"leavingScreen\",\"useEnhancedEffect\",\"useLayoutEffect\",\"useEffect\",\"SwipeableDrawer\",\"forwardRef\",\"inProps\",\"ref\",\"theme\",\"props\",\"getThemeProps\",\"name\",\"_props$anchor\",\"_props$disableBackdro\",\"disableBackdropTransition\",\"_props$disableDiscove\",\"disableDiscovery\",\"_props$disableSwipeTo\",\"disableSwipeToOpen\",\"hideBackdrop\",\"_props$hysteresis\",\"hysteresis\",\"_props$minFlingVeloci\",\"minFlingVelocity\",\"_props$ModalProps\",\"ModalProps\",\"BackdropProps\",\"ModalPropsProp\",\"onClose\",\"onOpen\",\"open\",\"_props$PaperProps\",\"PaperProps\",\"SwipeAreaProps\",\"_props$swipeAreaWidth\",\"swipeAreaWidth\",\"_props$transitionDura\",\"transitionDuration\",\"_props$variant\",\"variant\",\"other\",\"_React$useState\",\"useState\",\"maybeSwiping\",\"setMaybeSwiping\",\"swipeInstance\",\"useRef\",\"isSwiping\",\"swipeAreaRef\",\"backdropRef\",\"paperRef\",\"touchDetected\",\"calculatedDurationRef\",\"setPosition\",\"useCallback\",\"translate\",\"options\",\"arguments\",\"length\",\"undefined\",\"_options$mode\",\"mode\",\"_options$changeTransi\",\"changeTransition\",\"anchorRtl\",\"getAnchor\",\"rtlTranslateMultiplier\",\"indexOf\",\"transform\",\"isHorizontal\",\"concat\",\"drawerStyle\",\"style\",\"webkitTransform\",\"transition\",\"transitions\",\"create\",\"getTransitionProps\",\"timeout\",\"webkitTransition\",\"backdropStyle\",\"opacity\",\"handleBodyTouchEnd\",\"event\",\"horizontal\",\"changedTouches\",\"startLocation\",\"startX\",\"startY\",\"maxTranslate\",\"currentTranslate\",\"Math\",\"min\",\"max\",\"translateRatio\",\"abs\",\"velocity\",\"handleBodyTouchMove\",\"currentX\",\"currentY\",\"contains\",\"target\",\"element\",\"rootNode\",\"getComputedStyle\",\"getPropertyValue\",\"scrollWidth\",\"scrollHeight\",\"push\",\"parentElement\",\"nativeHandler\",\"dx\",\"dy\",\"cancelable\",\"preventDefault\",\"definitelySwiping\",\"UNCERTAINTY_THRESHOLD\",\"paperHit\",\"lastTranslate\",\"lastTime\",\"performance\",\"now\",\"handleBodyTouchStart\",\"defaultPrevented\",\"muiHandled\",\"doc\",\"addEventListener\",\"passive\",\"removeEventListener\",\"handleBackdropRef\",\"instance\",\"findDOMNode\",\"createElement\",\"Fragment\",\"pointerEvents\",\"width\",\"propTypes\",\"oneOf\",\"children\",\"node\",\"bool\",\"number\",\"component\",\"elementTypeAcceptingRef\",\"func\",\"isRequired\",\"object\",\"oneOfType\"]\n}\n"]