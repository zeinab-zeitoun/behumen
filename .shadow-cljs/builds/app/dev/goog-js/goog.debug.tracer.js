["^ ","~:resource-id",["~:shadow.build.classpath/resource","goog/debug/tracer.js"],"~:js","goog.provide(\"goog.debug.StopTraceDetail\");\ngoog.provide(\"goog.debug.Trace\");\ngoog.require(\"goog.array\");\ngoog.require(\"goog.asserts\");\ngoog.require(\"goog.debug.Logger\");\ngoog.require(\"goog.iter\");\ngoog.require(\"goog.log\");\ngoog.require(\"goog.structs.Map\");\ngoog.require(\"goog.structs.SimplePool\");\ngoog.debug.Trace_ = function() {\n  this.events_ = [];\n  this.outstandingEvents_ = new goog.structs.Map;\n  this.startTime_ = 0;\n  this.tracerOverheadStart_ = 0;\n  this.tracerOverheadEnd_ = 0;\n  this.tracerOverheadComment_ = 0;\n  this.stats_ = new goog.structs.Map;\n  this.tracerCount_ = 0;\n  this.commentCount_ = 0;\n  this.nextId_ = 1;\n  this.eventPool_ = new goog.structs.SimplePool(0, 4000);\n  this.eventPool_.createObject = function() {\n    return new goog.debug.Trace_.Event_;\n  };\n  this.statPool_ = new goog.structs.SimplePool(0, 50);\n  this.statPool_.createObject = function() {\n    return new goog.debug.Trace_.Stat_;\n  };\n  var self = this;\n  this.idPool_ = new goog.structs.SimplePool(0, 2000);\n  this.idPool_.setCreateObjectFn(function() {\n    return self.nextId_++;\n  });\n  this.defaultThreshold_ = 3;\n  this.traceCallbacks_ = {};\n};\ngoog.debug.Trace_.prototype.logger_ = goog.log.getLogger(\"goog.debug.Trace\");\ngoog.debug.Trace_.prototype.MAX_TRACE_SIZE = 1000;\ngoog.debug.Trace_.EventType = {START:0, STOP:1, COMMENT:2};\ngoog.debug.Trace_.Stat_ = function() {\n  this.count = 0;\n  this.time = 0;\n  this.varAlloc = 0;\n};\ngoog.debug.Trace_.Stat_.prototype.type;\ngoog.debug.Trace_.Stat_.prototype.toString = function() {\n  var sb = [];\n  sb.push(this.type, \" \", this.count, \" (\", Math.round(this.time * 10) / 10, \" ms)\");\n  if (this.varAlloc) {\n    sb.push(\" [VarAlloc \\x3d \", this.varAlloc, \"]\");\n  }\n  return sb.join(\"\");\n};\ngoog.debug.Trace_.Event_ = function() {\n};\ngoog.debug.Trace_.Event_.prototype.type;\ngoog.debug.Trace_.Event_.prototype.eventType;\ngoog.debug.Trace_.Event_.prototype.id;\ngoog.debug.Trace_.Event_.prototype.comment;\ngoog.debug.Trace_.Event_.prototype.toTraceString = function(startTime, prevTime, indent) {\n  var sb = [];\n  if (prevTime == -1) {\n    sb.push(\"    \");\n  } else {\n    sb.push(goog.debug.Trace_.longToPaddedString_(this.eventTime - prevTime));\n  }\n  sb.push(\" \", goog.debug.Trace_.formatTime_(this.eventTime - startTime));\n  if (this.eventType == goog.debug.Trace_.EventType.START) {\n    sb.push(\" Start        \");\n  } else {\n    if (this.eventType == goog.debug.Trace_.EventType.STOP) {\n      sb.push(\" Done \");\n      var delta = this.stopTime - this.startTime;\n      sb.push(goog.debug.Trace_.longToPaddedString_(delta), \" ms \");\n    } else {\n      sb.push(\" Comment      \");\n    }\n  }\n  sb.push(indent, this);\n  if (this.totalVarAlloc > 0) {\n    sb.push(\"[VarAlloc \", this.totalVarAlloc, \"] \");\n  }\n  return sb.join(\"\");\n};\ngoog.debug.Trace_.Event_.prototype.toString = function() {\n  if (this.type == null) {\n    return goog.asserts.assert(this.comment);\n  } else {\n    return \"[\" + this.type + \"] \" + this.comment;\n  }\n};\ngoog.debug.Trace_.TracerCallbacks = function() {\n  this.start;\n  this.stop;\n  this.comment;\n};\ngoog.debug.Trace_.TRACE_CANCELLED_ = {wasCancelled:true};\ngoog.debug.Trace_.NORMAL_STOP_ = {};\ngoog.debug.Trace_.TracerCallbacks.sequence_ = function(fn1, fn2) {\n  return !fn1 ? fn2 : !fn2 ? fn1 : function() {\n    fn1.apply(undefined, arguments);\n    fn2.apply(undefined, arguments);\n  };\n};\ngoog.debug.Trace_.prototype.removeAllListeners = function() {\n  this.traceCallbacks_ = {};\n};\ngoog.debug.Trace_.prototype.addTraceCallbacks = function(callbacks) {\n  this.traceCallbacks_.start = goog.debug.Trace_.TracerCallbacks.sequence_(this.traceCallbacks_.start, callbacks.start);\n  this.traceCallbacks_.stop = goog.debug.Trace_.TracerCallbacks.sequence_(this.traceCallbacks_.stop, callbacks.stop);\n  this.traceCallbacks_.comment = goog.debug.Trace_.TracerCallbacks.sequence_(this.traceCallbacks_.comment, callbacks.comment);\n};\ngoog.debug.Trace_.prototype.setStartTime = function(startTime) {\n  this.startTime_ = startTime;\n};\ngoog.debug.Trace_.prototype.initCurrentTrace = function(defaultThreshold) {\n  this.reset(defaultThreshold);\n};\ngoog.debug.Trace_.prototype.clearCurrentTrace = function() {\n  this.reset(0);\n};\ngoog.debug.Trace_.prototype.clearOutstandingEvents_ = function() {\n  if (this.traceCallbacks_.stop) {\n    goog.iter.forEach(this.outstandingEvents_, function(startEvent) {\n      this.traceCallbacks_.stop(startEvent.id, goog.debug.Trace_.TRACE_CANCELLED_);\n    }, this);\n  }\n  this.outstandingEvents_.clear();\n};\ngoog.debug.Trace_.prototype.reset = function(defaultThreshold) {\n  this.defaultThreshold_ = defaultThreshold;\n  this.clearOutstandingEvents_();\n  this.releaseEvents_();\n  this.startTime_ = goog.debug.Trace_.now();\n  this.tracerOverheadStart_ = 0;\n  this.tracerOverheadEnd_ = 0;\n  this.tracerOverheadComment_ = 0;\n  this.tracerCount_ = 0;\n  this.commentCount_ = 0;\n  var keys = this.stats_.getKeys();\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var stat = this.stats_.get(key);\n    stat.count = 0;\n    stat.time = 0;\n    stat.varAlloc = 0;\n    this.statPool_.releaseObject(stat);\n  }\n  this.stats_.clear();\n};\ngoog.debug.Trace_.prototype.releaseEvents_ = function() {\n  for (var i = 0; i < this.events_.length; i++) {\n    var event = this.events_[i];\n    if (event.id) {\n      if (!this.outstandingEvents_.containsKey(event.id)) {\n        this.idPool_.releaseObject(event.id);\n        this.eventPool_.releaseObject(event);\n      }\n    } else {\n      this.eventPool_.releaseObject(event);\n    }\n  }\n  this.events_.length = 0;\n};\ngoog.debug.Trace_.prototype.startTracer = function(comment, opt_type) {\n  var tracerStartTime = goog.debug.Trace_.now();\n  var varAlloc = this.getTotalVarAlloc();\n  var outstandingEventCount = this.outstandingEvents_.getCount();\n  if (this.events_.length + outstandingEventCount > this.MAX_TRACE_SIZE) {\n    if (outstandingEventCount > this.MAX_TRACE_SIZE / 2) {\n      goog.log.warning(this.logger_, \"Giant thread trace. Clearing outstanding events.\");\n      this.clearOutstandingEvents_();\n    }\n    if (this.events_.length > this.MAX_TRACE_SIZE / 2) {\n      goog.log.warning(this.logger_, \"Giant thread trace. Clearing to avoid memory leak.\");\n      this.releaseEvents_();\n    }\n  }\n  goog.debug.Logger.logToProfilers(\"Start : \" + comment);\n  var event = this.eventPool_.getObject();\n  event.stopTime = undefined;\n  event.totalVarAlloc = varAlloc;\n  event.eventType = goog.debug.Trace_.EventType.START;\n  event.id = this.idPool_.getObject();\n  event.comment = comment;\n  event.type = opt_type;\n  this.events_.push(event);\n  this.outstandingEvents_.set(String(event.id), event);\n  this.tracerCount_++;\n  var now = goog.debug.Trace_.now();\n  event.startTime = event.eventTime = now;\n  this.tracerOverheadStart_ += now - tracerStartTime;\n  if (this.traceCallbacks_.start) {\n    this.traceCallbacks_.start(event.id, event.toString());\n  }\n  return event.id;\n};\ngoog.debug.Trace_.prototype.stopTracer = function(id, opt_silenceThreshold) {\n  var now = goog.debug.Trace_.now();\n  var silenceThreshold;\n  if (opt_silenceThreshold === 0) {\n    silenceThreshold = 0;\n  } else {\n    if (opt_silenceThreshold) {\n      silenceThreshold = opt_silenceThreshold;\n    } else {\n      silenceThreshold = this.defaultThreshold_;\n    }\n  }\n  var startEvent = this.outstandingEvents_.get(String(id));\n  if (startEvent == null) {\n    return null;\n  }\n  goog.asserts.assertNumber(id);\n  if (this.traceCallbacks_.stop) {\n    this.traceCallbacks_.stop(Number(id), goog.debug.Trace_.NORMAL_STOP_);\n  }\n  this.outstandingEvents_.remove(String(id));\n  var stopEvent;\n  var elapsed = now - startEvent.startTime;\n  if (elapsed < silenceThreshold) {\n    var count = this.events_.length;\n    for (var i = count - 1; i >= 0; i--) {\n      var nextEvent = this.events_[i];\n      if (nextEvent == startEvent) {\n        this.events_.splice(i, 1);\n        this.idPool_.releaseObject(startEvent.id);\n        this.eventPool_.releaseObject(startEvent);\n        break;\n      }\n    }\n  } else {\n    stopEvent = this.eventPool_.getObject();\n    stopEvent.id = undefined;\n    stopEvent.eventType = goog.debug.Trace_.EventType.STOP;\n    stopEvent.startTime = startEvent.startTime;\n    stopEvent.comment = startEvent.comment;\n    stopEvent.type = startEvent.type;\n    stopEvent.stopTime = stopEvent.eventTime = now;\n    this.events_.push(stopEvent);\n  }\n  var type = startEvent.type;\n  var stat = null;\n  if (type) {\n    stat = this.getStat_(type);\n    stat.count++;\n    stat.time += elapsed;\n  }\n  if (stopEvent) {\n    goog.debug.Logger.logToProfilers(\"Stop : \" + stopEvent.comment);\n    stopEvent.totalVarAlloc = this.getTotalVarAlloc();\n    if (stat) {\n      stat.varAlloc += stopEvent.totalVarAlloc - startEvent.totalVarAlloc;\n    }\n  }\n  var tracerFinishTime = goog.debug.Trace_.now();\n  this.tracerOverheadEnd_ += tracerFinishTime - now;\n  return elapsed;\n};\ngoog.debug.Trace_.prototype.setGcTracer = function(gcTracer) {\n  this.gcTracer_ = gcTracer;\n};\ngoog.debug.Trace_.prototype.getTotalVarAlloc = function() {\n  var gcTracer = this.gcTracer_;\n  if (gcTracer && gcTracer[\"isTracing\"]()) {\n    return gcTracer[\"totalVarAlloc\"];\n  }\n  return -1;\n};\ngoog.debug.Trace_.prototype.addComment = function(comment, opt_type, opt_timeStamp) {\n  var now = goog.debug.Trace_.now();\n  var timeStamp = opt_timeStamp ? opt_timeStamp : now;\n  var eventComment = this.eventPool_.getObject();\n  eventComment.startTime = undefined;\n  eventComment.stopTime = undefined;\n  eventComment.id = undefined;\n  eventComment.eventType = goog.debug.Trace_.EventType.COMMENT;\n  eventComment.eventTime = timeStamp;\n  eventComment.type = opt_type;\n  eventComment.comment = comment;\n  eventComment.totalVarAlloc = this.getTotalVarAlloc();\n  this.commentCount_++;\n  if (opt_timeStamp) {\n    if (this.traceCallbacks_.comment) {\n      this.traceCallbacks_.comment(eventComment.toString(), opt_timeStamp);\n    }\n    var numEvents = this.events_.length;\n    for (var i = 0; i < numEvents; i++) {\n      var event = this.events_[i];\n      var eventTime = event.eventTime;\n      if (eventTime > timeStamp) {\n        goog.array.insertAt(this.events_, eventComment, i);\n        break;\n      }\n    }\n    if (i == numEvents) {\n      this.events_.push(eventComment);\n    }\n  } else {\n    if (this.traceCallbacks_.comment) {\n      this.traceCallbacks_.comment(eventComment.toString());\n    }\n    this.events_.push(eventComment);\n  }\n  var type = eventComment.type;\n  if (type) {\n    var stat = this.getStat_(type);\n    stat.count++;\n  }\n  this.tracerOverheadComment_ += goog.debug.Trace_.now() - now;\n};\ngoog.debug.Trace_.prototype.getStat_ = function(type) {\n  var stat = this.stats_.get(type);\n  if (!stat) {\n    stat = this.statPool_.getObject();\n    stat.type = type;\n    this.stats_.set(type, stat);\n  }\n  return stat;\n};\ngoog.debug.Trace_.prototype.getFormattedTrace = function() {\n  return this.toString();\n};\ngoog.debug.Trace_.prototype.toString = function() {\n  var sb = [];\n  var etime = -1;\n  var indent = [];\n  for (var i = 0; i < this.events_.length; i++) {\n    var e = this.events_[i];\n    if (e.eventType == goog.debug.Trace_.EventType.STOP) {\n      indent.pop();\n    }\n    sb.push(\" \", e.toTraceString(this.startTime_, etime, indent.join(\"\")));\n    etime = e.eventTime;\n    sb.push(\"\\n\");\n    if (e.eventType == goog.debug.Trace_.EventType.START) {\n      indent.push(\"|  \");\n    }\n  }\n  if (this.outstandingEvents_.getCount() != 0) {\n    var now = goog.debug.Trace_.now();\n    sb.push(\" Unstopped timers:\\n\");\n    goog.iter.forEach(this.outstandingEvents_, function(startEvent) {\n      sb.push(\"  \", startEvent, \" (\", now - startEvent.startTime, \" ms, started at \", goog.debug.Trace_.formatTime_(startEvent.startTime), \")\\n\");\n    });\n  }\n  var statKeys = this.stats_.getKeys();\n  for (var i = 0; i < statKeys.length; i++) {\n    var stat = this.stats_.get(statKeys[i]);\n    if (stat.count > 1) {\n      sb.push(\" TOTAL \", stat, \"\\n\");\n    }\n  }\n  sb.push(\"Total tracers created \", this.tracerCount_, \"\\n\", \"Total comments created \", this.commentCount_, \"\\n\", \"Overhead start: \", this.tracerOverheadStart_, \" ms\\n\", \"Overhead end: \", this.tracerOverheadEnd_, \" ms\\n\", \"Overhead comment: \", this.tracerOverheadComment_, \" ms\\n\");\n  return sb.join(\"\");\n};\ngoog.debug.Trace_.longToPaddedString_ = function(v) {\n  v = Math.round(v);\n  var space = \"\";\n  if (v < 1000) {\n    space = \" \";\n  }\n  if (v < 100) {\n    space = \"  \";\n  }\n  if (v < 10) {\n    space = \"   \";\n  }\n  return space + v;\n};\ngoog.debug.Trace_.formatTime_ = function(time) {\n  time = Math.round(time);\n  var sec = time / 1000 % 60;\n  var ms = time % 1000;\n  return String(100 + sec).substring(1, 3) + \".\" + String(1000 + ms).substring(1, 4);\n};\ngoog.debug.Trace_.now = function() {\n  return goog.now();\n};\ngoog.debug.Trace = new goog.debug.Trace_;\ngoog.debug.StopTraceDetail = function() {\n  this.wasCancelled;\n};\n","~:source","// Copyright 2006 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview Definition of the Tracer class and associated classes.\n *\n * @see ../demos/tracer.html\n * @suppress {strictMissingProperties}\n */\n\ngoog.provide('goog.debug.StopTraceDetail');\ngoog.provide('goog.debug.Trace');\n\ngoog.require('goog.array');\ngoog.require('goog.asserts');\ngoog.require('goog.debug.Logger');\ngoog.require('goog.iter');\ngoog.require('goog.log');\ngoog.require('goog.structs.Map');\ngoog.require('goog.structs.SimplePool');\n\n\n\n/**\n * Class used for singleton goog.debug.Trace.  Used for timing slow points in\n * the code. Based on the java Tracer class but optimized for javascript.\n * See com.google.common.tracing.Tracer.\n * It is also possible to bridge from this class to other tracer classes via\n * adding listeners.\n * @constructor\n * @private\n */\ngoog.debug.Trace_ = function() {\n\n  /**\n   * Events in order.\n   * @private {!Array<!goog.debug.Trace_.Event_>}\n   */\n  this.events_ = [];\n\n  /**\n   * Outstanding events that have started but haven't yet ended. The keys are\n   * numeric ids and the values are goog.debug.Trace_.Event_ objects.\n   * @private {!goog.structs.Map<number, !goog.debug.Trace_.Event_>}\n   */\n  this.outstandingEvents_ = new goog.structs.Map();\n\n  /**\n   * Start time of the event trace\n   * @private {number}\n   */\n  this.startTime_ = 0;\n\n  /**\n   * Cummulative overhead of calls to startTracer\n   * @private {number}\n   */\n  this.tracerOverheadStart_ = 0;\n\n  /**\n   * Cummulative overhead of calls to endTracer\n   * @private {number}\n   */\n  this.tracerOverheadEnd_ = 0;\n\n  /**\n   * Cummulative overhead of calls to addComment\n   * @private {number}\n   */\n  this.tracerOverheadComment_ = 0;\n\n  /**\n   * Keeps stats on different types of tracers. The keys are strings and the\n   * values are goog.debug.Stat\n   * @private {!goog.structs.Map}\n   */\n  this.stats_ = new goog.structs.Map();\n\n  /**\n   * Total number of traces created in the trace.\n   * @private {number}\n   */\n  this.tracerCount_ = 0;\n\n  /**\n   * Total number of comments created in the trace.\n   * @private {number}\n   */\n  this.commentCount_ = 0;\n\n  /**\n   * Next id to use for the trace.\n   * @private {number}\n   */\n  this.nextId_ = 1;\n\n  /**\n   * A pool for goog.debug.Trace_.Event_ objects so we don't keep creating and\n   * garbage collecting these (which is very expensive in IE6).\n   * @private {!goog.structs.SimplePool}\n   */\n  this.eventPool_ = new goog.structs.SimplePool(0, 4000);\n  this.eventPool_.createObject = function() {\n    return new goog.debug.Trace_.Event_();\n  };\n\n\n  /**\n   * A pool for goog.debug.Trace_.Stat_ objects so we don't keep creating and\n   * garbage collecting these (which is very expensive in IE6).\n   * @private {!goog.structs.SimplePool}\n   */\n  this.statPool_ = new goog.structs.SimplePool(0, 50);\n  this.statPool_.createObject = function() {\n    return new goog.debug.Trace_.Stat_();\n  };\n\n  var self = this;\n\n  /** @private {!goog.structs.SimplePool<number>} */\n  this.idPool_ = new goog.structs.SimplePool(0, 2000);\n  this.idPool_.setCreateObjectFn(function() {\n    return self.nextId_++;\n  });\n\n  /**\n   * Default threshold below which a tracer shouldn't be reported\n   * @private {number}\n   */\n  this.defaultThreshold_ = 3;\n\n  /**\n   * An object containing three callback functions to be called when starting or\n   * stopping a trace, or creating a comment trace.\n   * @private {!goog.debug.Trace_.TracerCallbacks}\n   */\n  this.traceCallbacks_ = {};\n};\n\n\n/**\n * Logger for the tracer\n * @private @const {?goog.log.Logger}\n */\ngoog.debug.Trace_.prototype.logger_ = goog.log.getLogger('goog.debug.Trace');\n\n\n/**\n * Maximum size of the trace before we discard events\n * @type {number}\n */\ngoog.debug.Trace_.prototype.MAX_TRACE_SIZE = 1000;\n\n\n/**\n * Event type supported by tracer\n * @enum {number}\n */\ngoog.debug.Trace_.EventType = {\n  /**\n   * Start event type\n   */\n  START: 0,\n\n  /**\n   * Stop event type\n   */\n  STOP: 1,\n\n  /**\n   * Comment event type\n   */\n  COMMENT: 2\n};\n\n\n\n/**\n * Class to keep track of a stat of a single tracer type. Stores the count\n * and cumulative time.\n * @constructor\n * @private\n */\ngoog.debug.Trace_.Stat_ = function() {\n  /**\n   * Number of tracers\n   * @type {number}\n   */\n  this.count = 0;\n\n  /**\n   * Cumulative time of traces\n   * @type {number}\n   */\n  this.time = 0;\n\n  /**\n   * Total number of allocations for this tracer type\n   * @type {number}\n   */\n  this.varAlloc = 0;\n};\n\n\n/**\n * @type {string|null|undefined}\n */\ngoog.debug.Trace_.Stat_.prototype.type;\n\n\n/**\n * @return {string} A string describing the tracer stat.\n * @override\n */\ngoog.debug.Trace_.Stat_.prototype.toString = function() {\n  var sb = [];\n  sb.push(\n      this.type, ' ', this.count, ' (', Math.round(this.time * 10) / 10,\n      ' ms)');\n  if (this.varAlloc) {\n    sb.push(' [VarAlloc = ', this.varAlloc, ']');\n  }\n  return sb.join('');\n};\n\n\n\n/**\n * Private class used to encapsulate a single event, either the start or stop\n * of a tracer.\n * @constructor\n * @private\n */\ngoog.debug.Trace_.Event_ = function() {\n  // the fields are different for different events - see usage in code\n};\n\n\n/**\n * @type {string|null|undefined}\n */\ngoog.debug.Trace_.Event_.prototype.type;\n\n\n/**\n * @type {goog.debug.Trace_.EventType|undefined}\n */\ngoog.debug.Trace_.Event_.prototype.eventType;\n\n\n/**\n * @type {number|undefined}\n */\ngoog.debug.Trace_.Event_.prototype.id;\n\n\n/**\n * @type {string|undefined}\n */\ngoog.debug.Trace_.Event_.prototype.comment;\n\n\n/**\n * Returns a formatted string for the event.\n * @param {number} startTime The start time of the trace to generate relative\n * times.\n * @param {number} prevTime The completion time of the previous event or -1.\n * @param {string} indent Extra indent for the message\n *     if there was no previous event.\n * @return {string} The formatted tracer string.\n */\ngoog.debug.Trace_.Event_.prototype.toTraceString = function(\n    startTime, prevTime, indent) {\n  var sb = [];\n\n  if (prevTime == -1) {\n    sb.push('    ');\n  } else {\n    sb.push(goog.debug.Trace_.longToPaddedString_(this.eventTime - prevTime));\n  }\n\n  sb.push(' ', goog.debug.Trace_.formatTime_(this.eventTime - startTime));\n  if (this.eventType == goog.debug.Trace_.EventType.START) {\n    sb.push(' Start        ');\n  } else if (this.eventType == goog.debug.Trace_.EventType.STOP) {\n    sb.push(' Done ');\n    var delta = this.stopTime - this.startTime;\n    sb.push(goog.debug.Trace_.longToPaddedString_(delta), ' ms ');\n  } else {\n    sb.push(' Comment      ');\n  }\n\n  sb.push(indent, this);\n  if (this.totalVarAlloc > 0) {\n    sb.push('[VarAlloc ', this.totalVarAlloc, '] ');\n  }\n  return sb.join('');\n};\n\n\n/**\n * @return {string} A string describing the tracer event.\n * @override\n */\ngoog.debug.Trace_.Event_.prototype.toString = function() {\n  if (this.type == null) {\n    return goog.asserts.assert(this.comment);\n  } else {\n    return '[' + this.type + '] ' + this.comment;\n  }\n};\n\n\n/**\n * A class to specify the types of the callback functions used by\n * `addTraceCallbacks`.\n * @record\n */\ngoog.debug.Trace_.TracerCallbacks = function() {\n  /**\n   * A callback function to be called at `startTrace` with two parameters:\n   * a number as the started trace id and a string as the comment on the trace.\n   * @type {function(number, string)|undefined}\n   */\n  this.start;\n  /**\n   * A callback function to be called when a trace should be stopped either at\n   * `startTrace` or `clearOutstandingEvents_` with two parameters:\n   * a number as the id of the trace being stopped and an object containing\n   * extra information about stopping the trace (e.g. if it is cancelled).\n   * @type {function(number, !goog.debug.StopTraceDetail)|undefined}\n   */\n  this.stop;\n  /**\n   * A callback function to be called at `addComment` with two parameters:\n   * a string as the comment on the trace and an optional time stamp number (in\n   * milliseconds since epoch) when the comment should be added as a trace.\n   * @type {function(string, number=)|undefined}\n   */\n  this.comment;\n};\n\n\n/** @private @const {!goog.debug.StopTraceDetail} */\ngoog.debug.Trace_.TRACE_CANCELLED_ = {\n  wasCancelled: true\n};\n\n\n/** @private @const {!goog.debug.StopTraceDetail} */\ngoog.debug.Trace_.NORMAL_STOP_ = {};\n\n\n/**\n * A function that combines two function with the same parameters in a sequence.\n * @param {!Function|undefined} fn1 The first function to be combined.\n * @param {!Function|undefined} fn2 The second function to be combined.\n * @return {!Function|undefined} A function that calls the inputs in sequence.\n * @private\n */\ngoog.debug.Trace_.TracerCallbacks.sequence_ = function(fn1, fn2) {\n  return !fn1 ? fn2 : !fn2 ? fn1 : function() {\n    fn1.apply(undefined, arguments);\n    fn2.apply(undefined, arguments);\n  };\n};\n\n\n/**\n * Removes all registered callback functions. Mainly used for testing.\n */\ngoog.debug.Trace_.prototype.removeAllListeners = function() {\n  this.traceCallbacks_ = {};\n};\n\n\n/**\n * Adds up to three callback functions which are called on `startTracer`,\n * `stopTracer`, `clearOutstandingEvents_` and `addComment` in\n * order to bridge from the Closure tracer singleton object to any tracer class.\n * @param {!goog.debug.Trace_.TracerCallbacks} callbacks An object literal\n *   containing the callback functions.\n */\ngoog.debug.Trace_.prototype.addTraceCallbacks = function(callbacks) {\n  this.traceCallbacks_.start = goog.debug.Trace_.TracerCallbacks.sequence_(\n      this.traceCallbacks_.start, callbacks.start);\n  this.traceCallbacks_.stop = goog.debug.Trace_.TracerCallbacks.sequence_(\n      this.traceCallbacks_.stop, callbacks.stop);\n  this.traceCallbacks_.comment = goog.debug.Trace_.TracerCallbacks.sequence_(\n      this.traceCallbacks_.comment, callbacks.comment);\n};\n\n\n/**\n * Add the ability to explicitly set the start time. This is useful for example\n * for measuring initial load time where you can set a variable as soon as the\n * main page of the app is loaded and then later call this function when the\n * Tracer code has been loaded.\n * @param {number} startTime The start time to set.\n */\ngoog.debug.Trace_.prototype.setStartTime = function(startTime) {\n  this.startTime_ = startTime;\n};\n\n\n/**\n * Initializes and resets the current trace\n * @param {number} defaultThreshold The default threshold below which the\n * tracer output will be suppressed. Can be overridden on a per-Tracer basis.\n */\ngoog.debug.Trace_.prototype.initCurrentTrace = function(defaultThreshold) {\n  this.reset(defaultThreshold);\n};\n\n\n/**\n * Clears the current trace\n */\ngoog.debug.Trace_.prototype.clearCurrentTrace = function() {\n  this.reset(0);\n};\n\n\n/**\n * Clears the open traces and calls stop callback for them.\n * @private\n */\ngoog.debug.Trace_.prototype.clearOutstandingEvents_ = function() {\n  if (this.traceCallbacks_.stop) {\n    goog.iter.forEach(this.outstandingEvents_, function(startEvent) {\n      this.traceCallbacks_.stop(\n          startEvent.id, goog.debug.Trace_.TRACE_CANCELLED_);\n    }, this);\n  }\n  this.outstandingEvents_.clear();\n};\n\n\n/**\n * Resets the trace.\n * @param {number} defaultThreshold The default threshold below which the\n * tracer output will be suppressed. Can be overridden on a per-Tracer basis.\n */\ngoog.debug.Trace_.prototype.reset = function(defaultThreshold) {\n  this.defaultThreshold_ = defaultThreshold;\n\n  this.clearOutstandingEvents_();\n  this.releaseEvents_();\n  this.startTime_ = goog.debug.Trace_.now();\n  this.tracerOverheadStart_ = 0;\n  this.tracerOverheadEnd_ = 0;\n  this.tracerOverheadComment_ = 0;\n  this.tracerCount_ = 0;\n  this.commentCount_ = 0;\n\n  var keys = this.stats_.getKeys();\n  for (var i = 0; i < keys.length; i++) {\n    var key = keys[i];\n    var stat = this.stats_.get(key);\n    stat.count = 0;\n    stat.time = 0;\n    stat.varAlloc = 0;\n    this.statPool_.releaseObject(/** @type {Object} */ (stat));\n  }\n  this.stats_.clear();\n};\n\n\n/**\n * @private\n */\ngoog.debug.Trace_.prototype.releaseEvents_ = function() {\n  for (var i = 0; i < this.events_.length; i++) {\n    var event = this.events_[i];\n    if (event.id) {  // Only start events have id.\n      // Only release the start event and its id if it is already stopped - this\n      // is to avoid having multiple traces with the same id.\n      if (!this.outstandingEvents_.containsKey(event.id)) {\n        this.idPool_.releaseObject(event.id);\n        this.eventPool_.releaseObject(event);\n      }\n    } else {  // Release stop and comment events.\n      this.eventPool_.releaseObject(event);\n    }\n  }\n  this.events_.length = 0;\n};\n\n\n/**\n * Starts a tracer\n * @param {string} comment A comment used to identify the tracer. Does not\n *     need to be unique.\n * @param {string=} opt_type Type used to identify the tracer. If a Trace is\n *     given a type (the first argument to the constructor) and multiple Traces\n *     are done on that type then a \"TOTAL line will be produced showing the\n *     total number of traces and the sum of the time\n *     (\"TOTAL Database 2 (37 ms)\" in our example). These traces should be\n *     mutually exclusive or else the sum won't make sense (the time will\n *     be double counted if the second starts before the first ends).\n * @return {number} The identifier for the tracer that should be passed to the\n *     the stopTracer method.\n */\ngoog.debug.Trace_.prototype.startTracer = function(comment, opt_type) {\n  var tracerStartTime = goog.debug.Trace_.now();\n  var varAlloc = this.getTotalVarAlloc();\n  var outstandingEventCount = this.outstandingEvents_.getCount();\n  if (this.events_.length + outstandingEventCount > this.MAX_TRACE_SIZE) {\n    // This is less likely and probably indicates that a lot of traces\n    // aren't being closed. We want to avoid unnecessarily clearing\n    // this though in case the events do eventually finish.\n    if (outstandingEventCount > this.MAX_TRACE_SIZE / 2) {\n      goog.log.warning(\n          this.logger_, 'Giant thread trace. Clearing outstanding events.');\n      this.clearOutstandingEvents_();\n    }\n    // This is the more likely case. This usually means that we\n    // either forgot to clear the trace or else we are performing a\n    // very large number of events\n    if (this.events_.length > this.MAX_TRACE_SIZE / 2) {\n      goog.log.warning(\n          this.logger_, 'Giant thread trace. Clearing to avoid memory leak.');\n      this.releaseEvents_();\n    }\n  }\n\n  goog.debug.Logger.logToProfilers('Start : ' + comment);\n\n  /** @const */\n  var event =\n      /** @type {!goog.debug.Trace_.Event_} */ (this.eventPool_.getObject());\n  event.stopTime = undefined;\n  event.totalVarAlloc = varAlloc;\n  event.eventType = goog.debug.Trace_.EventType.START;\n  event.id = this.idPool_.getObject();\n  event.comment = comment;\n  event.type = opt_type;\n  this.events_.push(event);\n  this.outstandingEvents_.set(String(event.id), event);\n  this.tracerCount_++;\n  var now = goog.debug.Trace_.now();\n  event.startTime = event.eventTime = now;\n  this.tracerOverheadStart_ += now - tracerStartTime;\n  if (this.traceCallbacks_.start) {\n    this.traceCallbacks_.start(event.id, event.toString());\n  }\n  return event.id;\n};\n\n\n/**\n * Stops a tracer\n * @param {number|undefined|null} id The id of the tracer that is ending.\n * @param {number=} opt_silenceThreshold Threshold below which the tracer is\n *    silenced.\n * @return {?number} The elapsed time for the tracer or null if the tracer\n *    identitifer was not recognized.\n */\ngoog.debug.Trace_.prototype.stopTracer = function(id, opt_silenceThreshold) {\n  // this used to call goog.isDef(opt_silenceThreshold) but that causes an\n  // object allocation in IE for some reason (doh!). The following code doesn't\n  // cause an allocation\n  var now = goog.debug.Trace_.now();\n  var silenceThreshold;\n  if (opt_silenceThreshold === 0) {\n    silenceThreshold = 0;\n  } else if (opt_silenceThreshold) {\n    silenceThreshold = opt_silenceThreshold;\n  } else {\n    silenceThreshold = this.defaultThreshold_;\n  }\n\n  var startEvent = this.outstandingEvents_.get(String(id));\n  if (startEvent == null) {\n    return null;\n  }\n  goog.asserts.assertNumber(id);\n  if (this.traceCallbacks_.stop) {\n    this.traceCallbacks_.stop(Number(id), goog.debug.Trace_.NORMAL_STOP_);\n  }\n\n  this.outstandingEvents_.remove(String(id));\n\n  var stopEvent;\n  var elapsed = now - startEvent.startTime;\n  if (elapsed < silenceThreshold) {\n    var count = this.events_.length;\n    for (var i = count - 1; i >= 0; i--) {\n      var nextEvent = this.events_[i];\n      if (nextEvent == startEvent) {\n        this.events_.splice(i, 1);\n        this.idPool_.releaseObject(startEvent.id);\n        this.eventPool_.releaseObject(/** @type {Object} */ (startEvent));\n        break;\n      }\n    }\n  } else {\n    stopEvent =\n        /** @type {goog.debug.Trace_.Event_} */ (this.eventPool_.getObject());\n    stopEvent.id = undefined;\n    stopEvent.eventType = goog.debug.Trace_.EventType.STOP;\n    stopEvent.startTime = startEvent.startTime;\n    stopEvent.comment = startEvent.comment;\n    stopEvent.type = startEvent.type;\n    stopEvent.stopTime = stopEvent.eventTime = now;\n\n    this.events_.push(stopEvent);\n  }\n\n  var type = startEvent.type;\n  var stat = null;\n  if (type) {\n    stat = this.getStat_(type);\n    stat.count++;\n    stat.time += elapsed;\n  }\n  if (stopEvent) {\n    goog.debug.Logger.logToProfilers('Stop : ' + stopEvent.comment);\n\n    stopEvent.totalVarAlloc = this.getTotalVarAlloc();\n\n    if (stat) {\n      stat.varAlloc += (stopEvent.totalVarAlloc - startEvent.totalVarAlloc);\n    }\n  }\n  var tracerFinishTime = goog.debug.Trace_.now();\n  this.tracerOverheadEnd_ += tracerFinishTime - now;\n  return elapsed;\n};\n\n\n/**\n * Sets the ActiveX object that can be used to get GC tracing in IE6.\n * @param {Object} gcTracer GCTracer ActiveX object.\n */\ngoog.debug.Trace_.prototype.setGcTracer = function(gcTracer) {\n  this.gcTracer_ = gcTracer;\n};\n\n\n/**\n * Returns the total number of allocations since the GC stats were reset. Only\n * works in IE.\n * @return {number} The number of allocaitons or -1 if not supported.\n */\ngoog.debug.Trace_.prototype.getTotalVarAlloc = function() {\n  var gcTracer = this.gcTracer_;\n  // isTracing is defined on the ActiveX object.\n  if (gcTracer && gcTracer['isTracing']()) {\n    return gcTracer['totalVarAlloc'];\n  }\n  return -1;\n};\n\n\n/**\n * Adds a comment to the trace. Makes it possible to see when a specific event\n * happened in relation to the traces.\n * @param {string} comment A comment that is inserted into the trace.\n * @param {?string=} opt_type Type used to identify the tracer. If a comment is\n *     given a type and multiple comments are done on that type then a \"TOTAL\n *     line will be produced showing the total number of comments of that type.\n * @param {?number=} opt_timeStamp The timestamp to insert the comment. If not\n *    specified, the current time wil be used.\n */\ngoog.debug.Trace_.prototype.addComment = function(\n    comment, opt_type, opt_timeStamp) {\n  var now = goog.debug.Trace_.now();\n  var timeStamp = opt_timeStamp ? opt_timeStamp : now;\n\n  var eventComment =\n      /** @type {goog.debug.Trace_.Event_} */ (this.eventPool_.getObject());\n  eventComment.startTime = undefined;\n  eventComment.stopTime = undefined;\n  eventComment.id = undefined;\n  eventComment.eventType = goog.debug.Trace_.EventType.COMMENT;\n  eventComment.eventTime = timeStamp;\n  eventComment.type = opt_type;\n  eventComment.comment = comment;\n  eventComment.totalVarAlloc = this.getTotalVarAlloc();\n  this.commentCount_++;\n\n  if (opt_timeStamp) {\n    if (this.traceCallbacks_.comment) {\n      this.traceCallbacks_.comment(eventComment.toString(), opt_timeStamp);\n    }\n    var numEvents = this.events_.length;\n    for (var i = 0; i < numEvents; i++) {\n      var event = this.events_[i];\n      var eventTime = event.eventTime;\n\n      if (eventTime > timeStamp) {\n        goog.array.insertAt(this.events_, eventComment, i);\n        break;\n      }\n    }\n    if (i == numEvents) {\n      this.events_.push(eventComment);\n    }\n  } else {  // No time_stamp\n    if (this.traceCallbacks_.comment) {\n      this.traceCallbacks_.comment(eventComment.toString());\n    }\n    this.events_.push(eventComment);\n  }\n\n  var type = eventComment.type;\n  if (type) {\n    var stat = this.getStat_(type);\n    stat.count++;\n  }\n\n  this.tracerOverheadComment_ += goog.debug.Trace_.now() - now;\n};\n\n\n/**\n * Gets a stat object for a particular type. The stat object is created if it\n * hasn't yet been.\n * @param {string} type The type of stat.\n * @return {goog.debug.Trace_.Stat_} The stat object.\n * @private\n */\ngoog.debug.Trace_.prototype.getStat_ = function(type) {\n  var stat = this.stats_.get(type);\n  if (!stat) {\n    stat = /** @type {goog.debug.Trace_.Event_} */ (this.statPool_.getObject());\n    stat.type = type;\n    this.stats_.set(type, stat);\n  }\n  return /** @type {goog.debug.Trace_.Stat_} */ (stat);\n};\n\n\n/**\n * Returns a formatted string for the current trace\n * @return {string} A formatted string that shows the timings of the current\n *     trace.\n */\ngoog.debug.Trace_.prototype.getFormattedTrace = function() {\n  return this.toString();\n};\n\n\n/**\n * Returns a formatted string that describes the thread trace.\n * @return {string} A formatted string.\n * @override\n */\ngoog.debug.Trace_.prototype.toString = function() {\n  var sb = [];\n  var etime = -1;\n  var indent = [];\n  for (var i = 0; i < this.events_.length; i++) {\n    var e = this.events_[i];\n    if (e.eventType == goog.debug.Trace_.EventType.STOP) {\n      indent.pop();\n    }\n    sb.push(' ', e.toTraceString(this.startTime_, etime, indent.join('')));\n    etime = e.eventTime;\n    sb.push('\\n');\n    if (e.eventType == goog.debug.Trace_.EventType.START) {\n      indent.push('|  ');\n    }\n  }\n\n  if (this.outstandingEvents_.getCount() != 0) {\n    var now = goog.debug.Trace_.now();\n\n    sb.push(' Unstopped timers:\\n');\n    goog.iter.forEach(this.outstandingEvents_, function(startEvent) {\n      sb.push(\n          '  ', startEvent, ' (', now - startEvent.startTime,\n          ' ms, started at ',\n          goog.debug.Trace_.formatTime_(startEvent.startTime), ')\\n');\n    });\n  }\n\n  var statKeys = this.stats_.getKeys();\n  for (var i = 0; i < statKeys.length; i++) {\n    var stat = this.stats_.get(statKeys[i]);\n    if (stat.count > 1) {\n      sb.push(' TOTAL ', stat, '\\n');\n    }\n  }\n\n  sb.push(\n      'Total tracers created ', this.tracerCount_, '\\n',\n      'Total comments created ', this.commentCount_, '\\n', 'Overhead start: ',\n      this.tracerOverheadStart_, ' ms\\n', 'Overhead end: ',\n      this.tracerOverheadEnd_, ' ms\\n', 'Overhead comment: ',\n      this.tracerOverheadComment_, ' ms\\n');\n\n  return sb.join('');\n};\n\n\n/**\n * Converts 'v' to a string and pads it with up to 3 spaces for\n * improved alignment. TODO there must be a better way\n * @param {number} v A number.\n * @return {string} A padded string.\n * @private\n */\ngoog.debug.Trace_.longToPaddedString_ = function(v) {\n  v = Math.round(v);\n  // todo (pupius) - there should be a generic string in goog.string for this\n  var space = '';\n  if (v < 1000) space = ' ';\n  if (v < 100) space = '  ';\n  if (v < 10) space = '   ';\n  return space + v;\n};\n\n\n/**\n * Return the sec.ms part of time (if time = \"20:06:11.566\",  \"11.566\n * @param {number} time The time in MS.\n * @return {string} A formatted string as sec.ms'.\n * @private\n */\ngoog.debug.Trace_.formatTime_ = function(time) {\n  time = Math.round(time);\n  var sec = (time / 1000) % 60;\n  var ms = time % 1000;\n\n  // TODO their must be a nicer way to get zero padded integers\n  return String(100 + sec).substring(1, 3) + '.' +\n      String(1000 + ms).substring(1, 4);\n};\n\n\n/**\n * Returns the current time. Done through a wrapper function so it can be\n * overridden by application code. Gmail has an ActiveX extension that provides\n * higher precision timing info.\n * @return {number} The current time in milliseconds.\n */\ngoog.debug.Trace_.now = function() {\n  return goog.now();\n};\n\n\n/**\n * Singleton trace object\n * @type {goog.debug.Trace_}\n */\ngoog.debug.Trace = new goog.debug.Trace_();\n\n\n/**\n * The detail of calling the stop callback for a trace.\n * @record\n */\ngoog.debug.StopTraceDetail = function() {\n  /**\n   * The trace should be stopped since it has been cancelled. Note that this\n   * field is optional so, not-specifying it is like setting it to false.\n   * @type {boolean|undefined}\n   */\n  this.wasCancelled;\n};\n","~:compiled-at",1622535515690,"~:source-map-json","{\n\"version\":3,\n\"file\":\"goog.debug.tracer.js\",\n\"lineCount\":384,\n\"mappings\":\"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\",\n\"sources\":[\"goog/debug/tracer.js\"],\n\"sourcesContent\":[\"// Copyright 2006 The Closure Library Authors. All Rights Reserved.\\n//\\n// Licensed under the Apache License, Version 2.0 (the \\\"License\\\");\\n// you may not use this file except in compliance with the License.\\n// You may obtain a copy of the License at\\n//\\n//      http://www.apache.org/licenses/LICENSE-2.0\\n//\\n// Unless required by applicable law or agreed to in writing, software\\n// distributed under the License is distributed on an \\\"AS-IS\\\" BASIS,\\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n// See the License for the specific language governing permissions and\\n// limitations under the License.\\n\\n/**\\n * @fileoverview Definition of the Tracer class and associated classes.\\n *\\n * @see ../demos/tracer.html\\n * @suppress {strictMissingProperties}\\n */\\n\\ngoog.provide('goog.debug.StopTraceDetail');\\ngoog.provide('goog.debug.Trace');\\n\\ngoog.require('goog.array');\\ngoog.require('goog.asserts');\\ngoog.require('goog.debug.Logger');\\ngoog.require('goog.iter');\\ngoog.require('goog.log');\\ngoog.require('goog.structs.Map');\\ngoog.require('goog.structs.SimplePool');\\n\\n\\n\\n/**\\n * Class used for singleton goog.debug.Trace.  Used for timing slow points in\\n * the code. Based on the java Tracer class but optimized for javascript.\\n * See com.google.common.tracing.Tracer.\\n * It is also possible to bridge from this class to other tracer classes via\\n * adding listeners.\\n * @constructor\\n * @private\\n */\\ngoog.debug.Trace_ = function() {\\n\\n  /**\\n   * Events in order.\\n   * @private {!Array<!goog.debug.Trace_.Event_>}\\n   */\\n  this.events_ = [];\\n\\n  /**\\n   * Outstanding events that have started but haven't yet ended. The keys are\\n   * numeric ids and the values are goog.debug.Trace_.Event_ objects.\\n   * @private {!goog.structs.Map<number, !goog.debug.Trace_.Event_>}\\n   */\\n  this.outstandingEvents_ = new goog.structs.Map();\\n\\n  /**\\n   * Start time of the event trace\\n   * @private {number}\\n   */\\n  this.startTime_ = 0;\\n\\n  /**\\n   * Cummulative overhead of calls to startTracer\\n   * @private {number}\\n   */\\n  this.tracerOverheadStart_ = 0;\\n\\n  /**\\n   * Cummulative overhead of calls to endTracer\\n   * @private {number}\\n   */\\n  this.tracerOverheadEnd_ = 0;\\n\\n  /**\\n   * Cummulative overhead of calls to addComment\\n   * @private {number}\\n   */\\n  this.tracerOverheadComment_ = 0;\\n\\n  /**\\n   * Keeps stats on different types of tracers. The keys are strings and the\\n   * values are goog.debug.Stat\\n   * @private {!goog.structs.Map}\\n   */\\n  this.stats_ = new goog.structs.Map();\\n\\n  /**\\n   * Total number of traces created in the trace.\\n   * @private {number}\\n   */\\n  this.tracerCount_ = 0;\\n\\n  /**\\n   * Total number of comments created in the trace.\\n   * @private {number}\\n   */\\n  this.commentCount_ = 0;\\n\\n  /**\\n   * Next id to use for the trace.\\n   * @private {number}\\n   */\\n  this.nextId_ = 1;\\n\\n  /**\\n   * A pool for goog.debug.Trace_.Event_ objects so we don't keep creating and\\n   * garbage collecting these (which is very expensive in IE6).\\n   * @private {!goog.structs.SimplePool}\\n   */\\n  this.eventPool_ = new goog.structs.SimplePool(0, 4000);\\n  this.eventPool_.createObject = function() {\\n    return new goog.debug.Trace_.Event_();\\n  };\\n\\n\\n  /**\\n   * A pool for goog.debug.Trace_.Stat_ objects so we don't keep creating and\\n   * garbage collecting these (which is very expensive in IE6).\\n   * @private {!goog.structs.SimplePool}\\n   */\\n  this.statPool_ = new goog.structs.SimplePool(0, 50);\\n  this.statPool_.createObject = function() {\\n    return new goog.debug.Trace_.Stat_();\\n  };\\n\\n  var self = this;\\n\\n  /** @private {!goog.structs.SimplePool<number>} */\\n  this.idPool_ = new goog.structs.SimplePool(0, 2000);\\n  this.idPool_.setCreateObjectFn(function() {\\n    return self.nextId_++;\\n  });\\n\\n  /**\\n   * Default threshold below which a tracer shouldn't be reported\\n   * @private {number}\\n   */\\n  this.defaultThreshold_ = 3;\\n\\n  /**\\n   * An object containing three callback functions to be called when starting or\\n   * stopping a trace, or creating a comment trace.\\n   * @private {!goog.debug.Trace_.TracerCallbacks}\\n   */\\n  this.traceCallbacks_ = {};\\n};\\n\\n\\n/**\\n * Logger for the tracer\\n * @private @const {?goog.log.Logger}\\n */\\ngoog.debug.Trace_.prototype.logger_ = goog.log.getLogger('goog.debug.Trace');\\n\\n\\n/**\\n * Maximum size of the trace before we discard events\\n * @type {number}\\n */\\ngoog.debug.Trace_.prototype.MAX_TRACE_SIZE = 1000;\\n\\n\\n/**\\n * Event type supported by tracer\\n * @enum {number}\\n */\\ngoog.debug.Trace_.EventType = {\\n  /**\\n   * Start event type\\n   */\\n  START: 0,\\n\\n  /**\\n   * Stop event type\\n   */\\n  STOP: 1,\\n\\n  /**\\n   * Comment event type\\n   */\\n  COMMENT: 2\\n};\\n\\n\\n\\n/**\\n * Class to keep track of a stat of a single tracer type. Stores the count\\n * and cumulative time.\\n * @constructor\\n * @private\\n */\\ngoog.debug.Trace_.Stat_ = function() {\\n  /**\\n   * Number of tracers\\n   * @type {number}\\n   */\\n  this.count = 0;\\n\\n  /**\\n   * Cumulative time of traces\\n   * @type {number}\\n   */\\n  this.time = 0;\\n\\n  /**\\n   * Total number of allocations for this tracer type\\n   * @type {number}\\n   */\\n  this.varAlloc = 0;\\n};\\n\\n\\n/**\\n * @type {string|null|undefined}\\n */\\ngoog.debug.Trace_.Stat_.prototype.type;\\n\\n\\n/**\\n * @return {string} A string describing the tracer stat.\\n * @override\\n */\\ngoog.debug.Trace_.Stat_.prototype.toString = function() {\\n  var sb = [];\\n  sb.push(\\n      this.type, ' ', this.count, ' (', Math.round(this.time * 10) / 10,\\n      ' ms)');\\n  if (this.varAlloc) {\\n    sb.push(' [VarAlloc = ', this.varAlloc, ']');\\n  }\\n  return sb.join('');\\n};\\n\\n\\n\\n/**\\n * Private class used to encapsulate a single event, either the start or stop\\n * of a tracer.\\n * @constructor\\n * @private\\n */\\ngoog.debug.Trace_.Event_ = function() {\\n  // the fields are different for different events - see usage in code\\n};\\n\\n\\n/**\\n * @type {string|null|undefined}\\n */\\ngoog.debug.Trace_.Event_.prototype.type;\\n\\n\\n/**\\n * @type {goog.debug.Trace_.EventType|undefined}\\n */\\ngoog.debug.Trace_.Event_.prototype.eventType;\\n\\n\\n/**\\n * @type {number|undefined}\\n */\\ngoog.debug.Trace_.Event_.prototype.id;\\n\\n\\n/**\\n * @type {string|undefined}\\n */\\ngoog.debug.Trace_.Event_.prototype.comment;\\n\\n\\n/**\\n * Returns a formatted string for the event.\\n * @param {number} startTime The start time of the trace to generate relative\\n * times.\\n * @param {number} prevTime The completion time of the previous event or -1.\\n * @param {string} indent Extra indent for the message\\n *     if there was no previous event.\\n * @return {string} The formatted tracer string.\\n */\\ngoog.debug.Trace_.Event_.prototype.toTraceString = function(\\n    startTime, prevTime, indent) {\\n  var sb = [];\\n\\n  if (prevTime == -1) {\\n    sb.push('    ');\\n  } else {\\n    sb.push(goog.debug.Trace_.longToPaddedString_(this.eventTime - prevTime));\\n  }\\n\\n  sb.push(' ', goog.debug.Trace_.formatTime_(this.eventTime - startTime));\\n  if (this.eventType == goog.debug.Trace_.EventType.START) {\\n    sb.push(' Start        ');\\n  } else if (this.eventType == goog.debug.Trace_.EventType.STOP) {\\n    sb.push(' Done ');\\n    var delta = this.stopTime - this.startTime;\\n    sb.push(goog.debug.Trace_.longToPaddedString_(delta), ' ms ');\\n  } else {\\n    sb.push(' Comment      ');\\n  }\\n\\n  sb.push(indent, this);\\n  if (this.totalVarAlloc > 0) {\\n    sb.push('[VarAlloc ', this.totalVarAlloc, '] ');\\n  }\\n  return sb.join('');\\n};\\n\\n\\n/**\\n * @return {string} A string describing the tracer event.\\n * @override\\n */\\ngoog.debug.Trace_.Event_.prototype.toString = function() {\\n  if (this.type == null) {\\n    return goog.asserts.assert(this.comment);\\n  } else {\\n    return '[' + this.type + '] ' + this.comment;\\n  }\\n};\\n\\n\\n/**\\n * A class to specify the types of the callback functions used by\\n * `addTraceCallbacks`.\\n * @record\\n */\\ngoog.debug.Trace_.TracerCallbacks = function() {\\n  /**\\n   * A callback function to be called at `startTrace` with two parameters:\\n   * a number as the started trace id and a string as the comment on the trace.\\n   * @type {function(number, string)|undefined}\\n   */\\n  this.start;\\n  /**\\n   * A callback function to be called when a trace should be stopped either at\\n   * `startTrace` or `clearOutstandingEvents_` with two parameters:\\n   * a number as the id of the trace being stopped and an object containing\\n   * extra information about stopping the trace (e.g. if it is cancelled).\\n   * @type {function(number, !goog.debug.StopTraceDetail)|undefined}\\n   */\\n  this.stop;\\n  /**\\n   * A callback function to be called at `addComment` with two parameters:\\n   * a string as the comment on the trace and an optional time stamp number (in\\n   * milliseconds since epoch) when the comment should be added as a trace.\\n   * @type {function(string, number=)|undefined}\\n   */\\n  this.comment;\\n};\\n\\n\\n/** @private @const {!goog.debug.StopTraceDetail} */\\ngoog.debug.Trace_.TRACE_CANCELLED_ = {\\n  wasCancelled: true\\n};\\n\\n\\n/** @private @const {!goog.debug.StopTraceDetail} */\\ngoog.debug.Trace_.NORMAL_STOP_ = {};\\n\\n\\n/**\\n * A function that combines two function with the same parameters in a sequence.\\n * @param {!Function|undefined} fn1 The first function to be combined.\\n * @param {!Function|undefined} fn2 The second function to be combined.\\n * @return {!Function|undefined} A function that calls the inputs in sequence.\\n * @private\\n */\\ngoog.debug.Trace_.TracerCallbacks.sequence_ = function(fn1, fn2) {\\n  return !fn1 ? fn2 : !fn2 ? fn1 : function() {\\n    fn1.apply(undefined, arguments);\\n    fn2.apply(undefined, arguments);\\n  };\\n};\\n\\n\\n/**\\n * Removes all registered callback functions. Mainly used for testing.\\n */\\ngoog.debug.Trace_.prototype.removeAllListeners = function() {\\n  this.traceCallbacks_ = {};\\n};\\n\\n\\n/**\\n * Adds up to three callback functions which are called on `startTracer`,\\n * `stopTracer`, `clearOutstandingEvents_` and `addComment` in\\n * order to bridge from the Closure tracer singleton object to any tracer class.\\n * @param {!goog.debug.Trace_.TracerCallbacks} callbacks An object literal\\n *   containing the callback functions.\\n */\\ngoog.debug.Trace_.prototype.addTraceCallbacks = function(callbacks) {\\n  this.traceCallbacks_.start = goog.debug.Trace_.TracerCallbacks.sequence_(\\n      this.traceCallbacks_.start, callbacks.start);\\n  this.traceCallbacks_.stop = goog.debug.Trace_.TracerCallbacks.sequence_(\\n      this.traceCallbacks_.stop, callbacks.stop);\\n  this.traceCallbacks_.comment = goog.debug.Trace_.TracerCallbacks.sequence_(\\n      this.traceCallbacks_.comment, callbacks.comment);\\n};\\n\\n\\n/**\\n * Add the ability to explicitly set the start time. This is useful for example\\n * for measuring initial load time where you can set a variable as soon as the\\n * main page of the app is loaded and then later call this function when the\\n * Tracer code has been loaded.\\n * @param {number} startTime The start time to set.\\n */\\ngoog.debug.Trace_.prototype.setStartTime = function(startTime) {\\n  this.startTime_ = startTime;\\n};\\n\\n\\n/**\\n * Initializes and resets the current trace\\n * @param {number} defaultThreshold The default threshold below which the\\n * tracer output will be suppressed. Can be overridden on a per-Tracer basis.\\n */\\ngoog.debug.Trace_.prototype.initCurrentTrace = function(defaultThreshold) {\\n  this.reset(defaultThreshold);\\n};\\n\\n\\n/**\\n * Clears the current trace\\n */\\ngoog.debug.Trace_.prototype.clearCurrentTrace = function() {\\n  this.reset(0);\\n};\\n\\n\\n/**\\n * Clears the open traces and calls stop callback for them.\\n * @private\\n */\\ngoog.debug.Trace_.prototype.clearOutstandingEvents_ = function() {\\n  if (this.traceCallbacks_.stop) {\\n    goog.iter.forEach(this.outstandingEvents_, function(startEvent) {\\n      this.traceCallbacks_.stop(\\n          startEvent.id, goog.debug.Trace_.TRACE_CANCELLED_);\\n    }, this);\\n  }\\n  this.outstandingEvents_.clear();\\n};\\n\\n\\n/**\\n * Resets the trace.\\n * @param {number} defaultThreshold The default threshold below which the\\n * tracer output will be suppressed. Can be overridden on a per-Tracer basis.\\n */\\ngoog.debug.Trace_.prototype.reset = function(defaultThreshold) {\\n  this.defaultThreshold_ = defaultThreshold;\\n\\n  this.clearOutstandingEvents_();\\n  this.releaseEvents_();\\n  this.startTime_ = goog.debug.Trace_.now();\\n  this.tracerOverheadStart_ = 0;\\n  this.tracerOverheadEnd_ = 0;\\n  this.tracerOverheadComment_ = 0;\\n  this.tracerCount_ = 0;\\n  this.commentCount_ = 0;\\n\\n  var keys = this.stats_.getKeys();\\n  for (var i = 0; i < keys.length; i++) {\\n    var key = keys[i];\\n    var stat = this.stats_.get(key);\\n    stat.count = 0;\\n    stat.time = 0;\\n    stat.varAlloc = 0;\\n    this.statPool_.releaseObject(/** @type {Object} */ (stat));\\n  }\\n  this.stats_.clear();\\n};\\n\\n\\n/**\\n * @private\\n */\\ngoog.debug.Trace_.prototype.releaseEvents_ = function() {\\n  for (var i = 0; i < this.events_.length; i++) {\\n    var event = this.events_[i];\\n    if (event.id) {  // Only start events have id.\\n      // Only release the start event and its id if it is already stopped - this\\n      // is to avoid having multiple traces with the same id.\\n      if (!this.outstandingEvents_.containsKey(event.id)) {\\n        this.idPool_.releaseObject(event.id);\\n        this.eventPool_.releaseObject(event);\\n      }\\n    } else {  // Release stop and comment events.\\n      this.eventPool_.releaseObject(event);\\n    }\\n  }\\n  this.events_.length = 0;\\n};\\n\\n\\n/**\\n * Starts a tracer\\n * @param {string} comment A comment used to identify the tracer. Does not\\n *     need to be unique.\\n * @param {string=} opt_type Type used to identify the tracer. If a Trace is\\n *     given a type (the first argument to the constructor) and multiple Traces\\n *     are done on that type then a \\\"TOTAL line will be produced showing the\\n *     total number of traces and the sum of the time\\n *     (\\\"TOTAL Database 2 (37 ms)\\\" in our example). These traces should be\\n *     mutually exclusive or else the sum won't make sense (the time will\\n *     be double counted if the second starts before the first ends).\\n * @return {number} The identifier for the tracer that should be passed to the\\n *     the stopTracer method.\\n */\\ngoog.debug.Trace_.prototype.startTracer = function(comment, opt_type) {\\n  var tracerStartTime = goog.debug.Trace_.now();\\n  var varAlloc = this.getTotalVarAlloc();\\n  var outstandingEventCount = this.outstandingEvents_.getCount();\\n  if (this.events_.length + outstandingEventCount > this.MAX_TRACE_SIZE) {\\n    // This is less likely and probably indicates that a lot of traces\\n    // aren't being closed. We want to avoid unnecessarily clearing\\n    // this though in case the events do eventually finish.\\n    if (outstandingEventCount > this.MAX_TRACE_SIZE / 2) {\\n      goog.log.warning(\\n          this.logger_, 'Giant thread trace. Clearing outstanding events.');\\n      this.clearOutstandingEvents_();\\n    }\\n    // This is the more likely case. This usually means that we\\n    // either forgot to clear the trace or else we are performing a\\n    // very large number of events\\n    if (this.events_.length > this.MAX_TRACE_SIZE / 2) {\\n      goog.log.warning(\\n          this.logger_, 'Giant thread trace. Clearing to avoid memory leak.');\\n      this.releaseEvents_();\\n    }\\n  }\\n\\n  goog.debug.Logger.logToProfilers('Start : ' + comment);\\n\\n  /** @const */\\n  var event =\\n      /** @type {!goog.debug.Trace_.Event_} */ (this.eventPool_.getObject());\\n  event.stopTime = undefined;\\n  event.totalVarAlloc = varAlloc;\\n  event.eventType = goog.debug.Trace_.EventType.START;\\n  event.id = this.idPool_.getObject();\\n  event.comment = comment;\\n  event.type = opt_type;\\n  this.events_.push(event);\\n  this.outstandingEvents_.set(String(event.id), event);\\n  this.tracerCount_++;\\n  var now = goog.debug.Trace_.now();\\n  event.startTime = event.eventTime = now;\\n  this.tracerOverheadStart_ += now - tracerStartTime;\\n  if (this.traceCallbacks_.start) {\\n    this.traceCallbacks_.start(event.id, event.toString());\\n  }\\n  return event.id;\\n};\\n\\n\\n/**\\n * Stops a tracer\\n * @param {number|undefined|null} id The id of the tracer that is ending.\\n * @param {number=} opt_silenceThreshold Threshold below which the tracer is\\n *    silenced.\\n * @return {?number} The elapsed time for the tracer or null if the tracer\\n *    identitifer was not recognized.\\n */\\ngoog.debug.Trace_.prototype.stopTracer = function(id, opt_silenceThreshold) {\\n  // this used to call goog.isDef(opt_silenceThreshold) but that causes an\\n  // object allocation in IE for some reason (doh!). The following code doesn't\\n  // cause an allocation\\n  var now = goog.debug.Trace_.now();\\n  var silenceThreshold;\\n  if (opt_silenceThreshold === 0) {\\n    silenceThreshold = 0;\\n  } else if (opt_silenceThreshold) {\\n    silenceThreshold = opt_silenceThreshold;\\n  } else {\\n    silenceThreshold = this.defaultThreshold_;\\n  }\\n\\n  var startEvent = this.outstandingEvents_.get(String(id));\\n  if (startEvent == null) {\\n    return null;\\n  }\\n  goog.asserts.assertNumber(id);\\n  if (this.traceCallbacks_.stop) {\\n    this.traceCallbacks_.stop(Number(id), goog.debug.Trace_.NORMAL_STOP_);\\n  }\\n\\n  this.outstandingEvents_.remove(String(id));\\n\\n  var stopEvent;\\n  var elapsed = now - startEvent.startTime;\\n  if (elapsed < silenceThreshold) {\\n    var count = this.events_.length;\\n    for (var i = count - 1; i >= 0; i--) {\\n      var nextEvent = this.events_[i];\\n      if (nextEvent == startEvent) {\\n        this.events_.splice(i, 1);\\n        this.idPool_.releaseObject(startEvent.id);\\n        this.eventPool_.releaseObject(/** @type {Object} */ (startEvent));\\n        break;\\n      }\\n    }\\n  } else {\\n    stopEvent =\\n        /** @type {goog.debug.Trace_.Event_} */ (this.eventPool_.getObject());\\n    stopEvent.id = undefined;\\n    stopEvent.eventType = goog.debug.Trace_.EventType.STOP;\\n    stopEvent.startTime = startEvent.startTime;\\n    stopEvent.comment = startEvent.comment;\\n    stopEvent.type = startEvent.type;\\n    stopEvent.stopTime = stopEvent.eventTime = now;\\n\\n    this.events_.push(stopEvent);\\n  }\\n\\n  var type = startEvent.type;\\n  var stat = null;\\n  if (type) {\\n    stat = this.getStat_(type);\\n    stat.count++;\\n    stat.time += elapsed;\\n  }\\n  if (stopEvent) {\\n    goog.debug.Logger.logToProfilers('Stop : ' + stopEvent.comment);\\n\\n    stopEvent.totalVarAlloc = this.getTotalVarAlloc();\\n\\n    if (stat) {\\n      stat.varAlloc += (stopEvent.totalVarAlloc - startEvent.totalVarAlloc);\\n    }\\n  }\\n  var tracerFinishTime = goog.debug.Trace_.now();\\n  this.tracerOverheadEnd_ += tracerFinishTime - now;\\n  return elapsed;\\n};\\n\\n\\n/**\\n * Sets the ActiveX object that can be used to get GC tracing in IE6.\\n * @param {Object} gcTracer GCTracer ActiveX object.\\n */\\ngoog.debug.Trace_.prototype.setGcTracer = function(gcTracer) {\\n  this.gcTracer_ = gcTracer;\\n};\\n\\n\\n/**\\n * Returns the total number of allocations since the GC stats were reset. Only\\n * works in IE.\\n * @return {number} The number of allocaitons or -1 if not supported.\\n */\\ngoog.debug.Trace_.prototype.getTotalVarAlloc = function() {\\n  var gcTracer = this.gcTracer_;\\n  // isTracing is defined on the ActiveX object.\\n  if (gcTracer && gcTracer['isTracing']()) {\\n    return gcTracer['totalVarAlloc'];\\n  }\\n  return -1;\\n};\\n\\n\\n/**\\n * Adds a comment to the trace. Makes it possible to see when a specific event\\n * happened in relation to the traces.\\n * @param {string} comment A comment that is inserted into the trace.\\n * @param {?string=} opt_type Type used to identify the tracer. If a comment is\\n *     given a type and multiple comments are done on that type then a \\\"TOTAL\\n *     line will be produced showing the total number of comments of that type.\\n * @param {?number=} opt_timeStamp The timestamp to insert the comment. If not\\n *    specified, the current time wil be used.\\n */\\ngoog.debug.Trace_.prototype.addComment = function(\\n    comment, opt_type, opt_timeStamp) {\\n  var now = goog.debug.Trace_.now();\\n  var timeStamp = opt_timeStamp ? opt_timeStamp : now;\\n\\n  var eventComment =\\n      /** @type {goog.debug.Trace_.Event_} */ (this.eventPool_.getObject());\\n  eventComment.startTime = undefined;\\n  eventComment.stopTime = undefined;\\n  eventComment.id = undefined;\\n  eventComment.eventType = goog.debug.Trace_.EventType.COMMENT;\\n  eventComment.eventTime = timeStamp;\\n  eventComment.type = opt_type;\\n  eventComment.comment = comment;\\n  eventComment.totalVarAlloc = this.getTotalVarAlloc();\\n  this.commentCount_++;\\n\\n  if (opt_timeStamp) {\\n    if (this.traceCallbacks_.comment) {\\n      this.traceCallbacks_.comment(eventComment.toString(), opt_timeStamp);\\n    }\\n    var numEvents = this.events_.length;\\n    for (var i = 0; i < numEvents; i++) {\\n      var event = this.events_[i];\\n      var eventTime = event.eventTime;\\n\\n      if (eventTime > timeStamp) {\\n        goog.array.insertAt(this.events_, eventComment, i);\\n        break;\\n      }\\n    }\\n    if (i == numEvents) {\\n      this.events_.push(eventComment);\\n    }\\n  } else {  // No time_stamp\\n    if (this.traceCallbacks_.comment) {\\n      this.traceCallbacks_.comment(eventComment.toString());\\n    }\\n    this.events_.push(eventComment);\\n  }\\n\\n  var type = eventComment.type;\\n  if (type) {\\n    var stat = this.getStat_(type);\\n    stat.count++;\\n  }\\n\\n  this.tracerOverheadComment_ += goog.debug.Trace_.now() - now;\\n};\\n\\n\\n/**\\n * Gets a stat object for a particular type. The stat object is created if it\\n * hasn't yet been.\\n * @param {string} type The type of stat.\\n * @return {goog.debug.Trace_.Stat_} The stat object.\\n * @private\\n */\\ngoog.debug.Trace_.prototype.getStat_ = function(type) {\\n  var stat = this.stats_.get(type);\\n  if (!stat) {\\n    stat = /** @type {goog.debug.Trace_.Event_} */ (this.statPool_.getObject());\\n    stat.type = type;\\n    this.stats_.set(type, stat);\\n  }\\n  return /** @type {goog.debug.Trace_.Stat_} */ (stat);\\n};\\n\\n\\n/**\\n * Returns a formatted string for the current trace\\n * @return {string} A formatted string that shows the timings of the current\\n *     trace.\\n */\\ngoog.debug.Trace_.prototype.getFormattedTrace = function() {\\n  return this.toString();\\n};\\n\\n\\n/**\\n * Returns a formatted string that describes the thread trace.\\n * @return {string} A formatted string.\\n * @override\\n */\\ngoog.debug.Trace_.prototype.toString = function() {\\n  var sb = [];\\n  var etime = -1;\\n  var indent = [];\\n  for (var i = 0; i < this.events_.length; i++) {\\n    var e = this.events_[i];\\n    if (e.eventType == goog.debug.Trace_.EventType.STOP) {\\n      indent.pop();\\n    }\\n    sb.push(' ', e.toTraceString(this.startTime_, etime, indent.join('')));\\n    etime = e.eventTime;\\n    sb.push('\\\\n');\\n    if (e.eventType == goog.debug.Trace_.EventType.START) {\\n      indent.push('|  ');\\n    }\\n  }\\n\\n  if (this.outstandingEvents_.getCount() != 0) {\\n    var now = goog.debug.Trace_.now();\\n\\n    sb.push(' Unstopped timers:\\\\n');\\n    goog.iter.forEach(this.outstandingEvents_, function(startEvent) {\\n      sb.push(\\n          '  ', startEvent, ' (', now - startEvent.startTime,\\n          ' ms, started at ',\\n          goog.debug.Trace_.formatTime_(startEvent.startTime), ')\\\\n');\\n    });\\n  }\\n\\n  var statKeys = this.stats_.getKeys();\\n  for (var i = 0; i < statKeys.length; i++) {\\n    var stat = this.stats_.get(statKeys[i]);\\n    if (stat.count > 1) {\\n      sb.push(' TOTAL ', stat, '\\\\n');\\n    }\\n  }\\n\\n  sb.push(\\n      'Total tracers created ', this.tracerCount_, '\\\\n',\\n      'Total comments created ', this.commentCount_, '\\\\n', 'Overhead start: ',\\n      this.tracerOverheadStart_, ' ms\\\\n', 'Overhead end: ',\\n      this.tracerOverheadEnd_, ' ms\\\\n', 'Overhead comment: ',\\n      this.tracerOverheadComment_, ' ms\\\\n');\\n\\n  return sb.join('');\\n};\\n\\n\\n/**\\n * Converts 'v' to a string and pads it with up to 3 spaces for\\n * improved alignment. TODO there must be a better way\\n * @param {number} v A number.\\n * @return {string} A padded string.\\n * @private\\n */\\ngoog.debug.Trace_.longToPaddedString_ = function(v) {\\n  v = Math.round(v);\\n  // todo (pupius) - there should be a generic string in goog.string for this\\n  var space = '';\\n  if (v < 1000) space = ' ';\\n  if (v < 100) space = '  ';\\n  if (v < 10) space = '   ';\\n  return space + v;\\n};\\n\\n\\n/**\\n * Return the sec.ms part of time (if time = \\\"20:06:11.566\\\",  \\\"11.566\\n * @param {number} time The time in MS.\\n * @return {string} A formatted string as sec.ms'.\\n * @private\\n */\\ngoog.debug.Trace_.formatTime_ = function(time) {\\n  time = Math.round(time);\\n  var sec = (time / 1000) % 60;\\n  var ms = time % 1000;\\n\\n  // TODO their must be a nicer way to get zero padded integers\\n  return String(100 + sec).substring(1, 3) + '.' +\\n      String(1000 + ms).substring(1, 4);\\n};\\n\\n\\n/**\\n * Returns the current time. Done through a wrapper function so it can be\\n * overridden by application code. Gmail has an ActiveX extension that provides\\n * higher precision timing info.\\n * @return {number} The current time in milliseconds.\\n */\\ngoog.debug.Trace_.now = function() {\\n  return goog.now();\\n};\\n\\n\\n/**\\n * Singleton trace object\\n * @type {goog.debug.Trace_}\\n */\\ngoog.debug.Trace = new goog.debug.Trace_();\\n\\n\\n/**\\n * The detail of calling the stop callback for a trace.\\n * @record\\n */\\ngoog.debug.StopTraceDetail = function() {\\n  /**\\n   * The trace should be stopped since it has been cancelled. Note that this\\n   * field is optional so, not-specifying it is like setting it to false.\\n   * @type {boolean|undefined}\\n   */\\n  this.wasCancelled;\\n};\\n\"],\n\"names\":[\"goog\",\"provide\",\"require\",\"debug\",\"Trace_\",\"goog.debug.Trace_\",\"events_\",\"outstandingEvents_\",\"structs\",\"Map\",\"startTime_\",\"tracerOverheadStart_\",\"tracerOverheadEnd_\",\"tracerOverheadComment_\",\"stats_\",\"tracerCount_\",\"commentCount_\",\"nextId_\",\"eventPool_\",\"SimplePool\",\"createObject\",\"this.eventPool_.createObject\",\"Event_\",\"statPool_\",\"this.statPool_.createObject\",\"Stat_\",\"self\",\"idPool_\",\"setCreateObjectFn\",\"defaultThreshold_\",\"traceCallbacks_\",\"prototype\",\"logger_\",\"log\",\"getLogger\",\"MAX_TRACE_SIZE\",\"EventType\",\"START\",\"STOP\",\"COMMENT\",\"goog.debug.Trace_.Stat_\",\"count\",\"time\",\"varAlloc\",\"type\",\"toString\",\"goog.debug.Trace_.Stat_.prototype.toString\",\"sb\",\"push\",\"Math\",\"round\",\"join\",\"goog.debug.Trace_.Event_\",\"eventType\",\"id\",\"comment\",\"toTraceString\",\"goog.debug.Trace_.Event_.prototype.toTraceString\",\"startTime\",\"prevTime\",\"indent\",\"longToPaddedString_\",\"eventTime\",\"formatTime_\",\"delta\",\"stopTime\",\"totalVarAlloc\",\"goog.debug.Trace_.Event_.prototype.toString\",\"asserts\",\"assert\",\"TracerCallbacks\",\"goog.debug.Trace_.TracerCallbacks\",\"start\",\"stop\",\"TRACE_CANCELLED_\",\"wasCancelled\",\"NORMAL_STOP_\",\"sequence_\",\"goog.debug.Trace_.TracerCallbacks.sequence_\",\"fn1\",\"fn2\",\"apply\",\"undefined\",\"arguments\",\"removeAllListeners\",\"goog.debug.Trace_.prototype.removeAllListeners\",\"addTraceCallbacks\",\"goog.debug.Trace_.prototype.addTraceCallbacks\",\"callbacks\",\"setStartTime\",\"goog.debug.Trace_.prototype.setStartTime\",\"initCurrentTrace\",\"goog.debug.Trace_.prototype.initCurrentTrace\",\"defaultThreshold\",\"reset\",\"clearCurrentTrace\",\"goog.debug.Trace_.prototype.clearCurrentTrace\",\"clearOutstandingEvents_\",\"goog.debug.Trace_.prototype.clearOutstandingEvents_\",\"iter\",\"forEach\",\"startEvent\",\"clear\",\"goog.debug.Trace_.prototype.reset\",\"releaseEvents_\",\"now\",\"keys\",\"getKeys\",\"i\",\"length\",\"key\",\"stat\",\"get\",\"releaseObject\",\"goog.debug.Trace_.prototype.releaseEvents_\",\"event\",\"containsKey\",\"startTracer\",\"goog.debug.Trace_.prototype.startTracer\",\"opt_type\",\"tracerStartTime\",\"getTotalVarAlloc\",\"outstandingEventCount\",\"getCount\",\"warning\",\"Logger\",\"logToProfilers\",\"getObject\",\"set\",\"String\",\"stopTracer\",\"goog.debug.Trace_.prototype.stopTracer\",\"opt_silenceThreshold\",\"silenceThreshold\",\"assertNumber\",\"Number\",\"remove\",\"stopEvent\",\"elapsed\",\"nextEvent\",\"splice\",\"getStat_\",\"tracerFinishTime\",\"setGcTracer\",\"goog.debug.Trace_.prototype.setGcTracer\",\"gcTracer\",\"gcTracer_\",\"goog.debug.Trace_.prototype.getTotalVarAlloc\",\"addComment\",\"goog.debug.Trace_.prototype.addComment\",\"opt_timeStamp\",\"timeStamp\",\"eventComment\",\"numEvents\",\"array\",\"insertAt\",\"goog.debug.Trace_.prototype.getStat_\",\"getFormattedTrace\",\"goog.debug.Trace_.prototype.getFormattedTrace\",\"goog.debug.Trace_.prototype.toString\",\"etime\",\"e\",\"pop\",\"statKeys\",\"goog.debug.Trace_.longToPaddedString_\",\"v\",\"space\",\"goog.debug.Trace_.formatTime_\",\"sec\",\"ms\",\"substring\",\"goog.debug.Trace_.now\",\"Trace\",\"StopTraceDetail\",\"goog.debug.StopTraceDetail\"]\n}\n"]