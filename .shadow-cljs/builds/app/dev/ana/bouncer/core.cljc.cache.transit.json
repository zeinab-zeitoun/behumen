["^ ","~:output",["^ ","~:js","goog.provide('bouncer.core');\nbouncer.core.build_multi_step = (function bouncer$core$build_multi_step(var_args){\nvar G__65689 = arguments.length;\nswitch (G__65689) {\ncase 2:\nreturn bouncer.core.build_multi_step.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));\n\nbreak;\ncase 3:\nreturn bouncer.core.build_multi_step.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));\n\nbreak;\ndefault:\nthrow (new Error([\"Invalid arity: \",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));\n\n}\n});\n\n(bouncer.core.build_multi_step.cljs$core$IFn$_invoke$arity$2 = (function (key_or_vec,fn_vec){\nreturn bouncer.core.build_multi_step.cljs$core$IFn$_invoke$arity$3(key_or_vec,fn_vec,cljs.core.PersistentVector.EMPTY);\n}));\n\n(bouncer.core.build_multi_step.cljs$core$IFn$_invoke$arity$3 = (function (key_or_vec,p__65694,acc){\nwhile(true){\nvar vec__65695 = p__65694;\nvar seq__65696 = cljs.core.seq(vec__65695);\nvar first__65697 = cljs.core.first(seq__65696);\nvar seq__65696__$1 = cljs.core.next(seq__65696);\nvar f_or_list = first__65697;\nvar rest = seq__65696__$1;\nif(cljs.core.not(f_or_list)){\nreturn acc;\n} else {\nif(cljs.core.sequential_QMARK_(f_or_list)){\nvar vec__65698 = f_or_list;\nvar seq__65699 = cljs.core.seq(vec__65698);\nvar first__65700 = cljs.core.first(seq__65699);\nvar seq__65699__$1 = cljs.core.next(seq__65699);\nvar f = first__65700;\nvar opts = seq__65699__$1;\nvar G__65760 = key_or_vec;\nvar G__65761 = rest;\nvar G__65762 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(acc,cljs.core.concat.cljs$core$IFn$_invoke$arity$2(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [f,key_or_vec], null),opts));\nkey_or_vec = G__65760;\np__65694 = G__65761;\nacc = G__65762;\ncontinue;\n} else {\nvar G__65763 = key_or_vec;\nvar G__65764 = rest;\nvar G__65765 = cljs.core.conj.cljs$core$IFn$_invoke$arity$2(acc,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [f_or_list,key_or_vec], null));\nkey_or_vec = G__65763;\np__65694 = G__65764;\nacc = G__65765;\ncontinue;\n\n}\n}\nbreak;\n}\n}));\n\n(bouncer.core.build_multi_step.cljs$lang$maxFixedArity = 3);\n\n/**\n * Takes two arguments:\n * \n *   `parent-keyword` is a :keyword - or a vector of :keywords denoting a path in a associative structure\n * \n *   `validations-map` is a map of forms following this spec:\n * \n * \n *    {:keyword [f g] :another-keyword h}\n * \n * \n *   Merges `:parent-keyword` with every first element of validations-map, transforming it into:\n * \n * \n *    ([:parent-keyword :keyword] [f g] [:parent-keyword :another-keyword] h)\n */\nbouncer.core.merge_path = (function bouncer$core$merge_path(parent_key,validations_map){\nvar parent_key__$1 = (((parent_key instanceof cljs.core.Keyword))?new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [parent_key], null):parent_key);\nreturn cljs.core.mapcat.cljs$core$IFn$_invoke$arity$variadic((function (p__65703){\nvar vec__65704 = p__65703;\nvar key = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__65704,(0),null);\nvar validations = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__65704,(1),null);\nif(cljs.core.vector_QMARK_(key)){\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.vector,cljs.core.concat.cljs$core$IFn$_invoke$arity$2(parent_key__$1,key)),validations], null);\n} else {\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.vector,cljs.core.concat.cljs$core$IFn$_invoke$arity$2(parent_key__$1,new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [key], null))),validations], null);\n}\n}),cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([validations_map], 0));\n});\nbouncer.core.build_steps = (function bouncer$core$build_steps(p__65711){\nvar vec__65712 = p__65711;\nvar seq__65713 = cljs.core.seq(vec__65712);\nvar first__65714 = cljs.core.first(seq__65713);\nvar seq__65713__$1 = cljs.core.next(seq__65713);\nvar head = first__65714;\nvar tail = seq__65713__$1;\nvar forms = vec__65712;\nvar forms__$1 = ((cljs.core.map_QMARK_(head))?cljs.core.vec(cljs.core.mapcat.cljs$core$IFn$_invoke$arity$variadic(cljs.core.identity,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([head], 0))):forms);\nreturn cljs.core.reduce.cljs$core$IFn$_invoke$arity$3((function (acc,p__65716){\nvar vec__65717 = p__65716;\nvar key_or_vec = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__65717,(0),null);\nvar sym_or_coll = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__65717,(1),null);\nvar rule = vec__65717;\nif(cljs.core.vector_QMARK_(sym_or_coll)){\nreturn cljs.core.concat.cljs$core$IFn$_invoke$arity$2(acc,bouncer.core.build_multi_step.cljs$core$IFn$_invoke$arity$2(key_or_vec,sym_or_coll));\n} else {\nif(cljs.core.map_QMARK_(sym_or_coll)){\nreturn cljs.core.concat.cljs$core$IFn$_invoke$arity$2(acc,(function (){var G__65720 = bouncer.core.merge_path(key_or_vec,sym_or_coll);\nreturn (bouncer.core.build_steps.cljs$core$IFn$_invoke$arity$1 ? bouncer.core.build_steps.cljs$core$IFn$_invoke$arity$1(G__65720) : bouncer.core.build_steps.call(null,G__65720));\n})());\n} else {\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2(acc,new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [sym_or_coll,key_or_vec], null));\n\n}\n}\n}),cljs.core.PersistentVector.EMPTY,cljs.core.partition.cljs$core$IFn$_invoke$arity$2((2),forms__$1));\n});\nbouncer.core.pre_condition_met_QMARK_ = (function bouncer$core$pre_condition_met_QMARK_(pre_fn,map){\nvar or__4126__auto__ = (pre_fn == null);\nif(or__4126__auto__){\nreturn or__4126__auto__;\n} else {\nreturn (pre_fn.cljs$core$IFn$_invoke$arity$1 ? pre_fn.cljs$core$IFn$_invoke$arity$1(map) : pre_fn.call(null,map));\n}\n});\n/**\n * Wraps pred in the context of validating a single value\n * \n *   - `acc`  is the map being validated\n * \n *   - `pred` is a validator\n * \n *   - `k`    the path to the value to be validated in the associative structure `acc`\n * \n *   - `args` any extra args to pred\n * \n *   It only runs pred if:\n * \n *   - the validator contains a pre-condition *and* it is met or;\n *   - the validator is optional  *and* there is a non-nil value to be validated (this information is read from pred's metadata) or;\n *   - there are no previous errors for the given path\n * \n *   Returns `acc` augmented with a namespace qualified ::errors keyword\n */\nbouncer.core.wrap = (function bouncer$core$wrap(message_fn,acc,p__65722){\nvar vec__65723 = p__65722;\nvar seq__65724 = cljs.core.seq(vec__65723);\nvar first__65725 = cljs.core.first(seq__65724);\nvar seq__65724__$1 = cljs.core.next(seq__65724);\nvar pred = first__65725;\nvar first__65725__$1 = cljs.core.first(seq__65724__$1);\nvar seq__65724__$2 = cljs.core.next(seq__65724__$1);\nvar k = first__65725__$1;\nvar args = seq__65724__$2;\nvar k__$1 = ((cljs.core.vector_QMARK_(k))?k:new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [k], null));\nvar error_path = cljs.core.cons(new cljs.core.Keyword(\"bouncer.core\",\"errors\",\"bouncer.core/errors\",-444562289),k__$1);\nvar map__65726 = cljs.core.meta(pred);\nvar map__65726__$1 = (((((!((map__65726 == null))))?(((((map__65726.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__65726.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__65726):map__65726);\nvar metadata = map__65726__$1;\nvar optional = cljs.core.get.cljs$core$IFn$_invoke$arity$3(map__65726__$1,new cljs.core.Keyword(null,\"optional\",\"optional\",2053951509),false);\nvar default_message_format = cljs.core.get.cljs$core$IFn$_invoke$arity$3(map__65726__$1,new cljs.core.Keyword(null,\"default-message-format\",\"default-message-format\",179806141),\"Custom validation failed for %s\");\nvar meta_with_defaults = cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic(cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([metadata,new cljs.core.PersistentArrayMap(null, 2, [new cljs.core.Keyword(null,\"default-message-format\",\"default-message-format\",179806141),default_message_format,new cljs.core.Keyword(null,\"optional\",\"optional\",2053951509),optional], null)], 0));\nvar vec__65727 = cljs.core.split_with(cljs.core.complement(cljs.core.keyword_QMARK_),args);\nvar args__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__65727,(0),null);\nvar opts = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__65727,(1),null);\nvar map__65730 = cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,opts);\nvar map__65730__$1 = (((((!((map__65730 == null))))?(((((map__65730.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__65730.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__65730):map__65730);\nvar message = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__65730__$1,new cljs.core.Keyword(null,\"message\",\"message\",-406056002));\nvar pre = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__65730__$1,new cljs.core.Keyword(null,\"pre\",\"pre\",2118456869));\nvar pred_subject = cljs.core.get_in.cljs$core$IFn$_invoke$arity$2(acc,k__$1);\nif(cljs.core.truth_(bouncer.core.pre_condition_met_QMARK_(pre,acc))){\nif(cljs.core.truth_((function (){var or__4126__auto__ = (function (){var and__4115__auto__ = optional;\nif(cljs.core.truth_(and__4115__auto__)){\nreturn (pred_subject == null);\n} else {\nreturn and__4115__auto__;\n}\n})();\nif(cljs.core.truth_(or__4126__auto__)){\nreturn or__4126__auto__;\n} else {\nvar or__4126__auto____$1 = (!(cljs.core.empty_QMARK_(cljs.core.get_in.cljs$core$IFn$_invoke$arity$2(acc,error_path))));\nif(or__4126__auto____$1){\nreturn or__4126__auto____$1;\n} else {\nreturn cljs.core.apply.cljs$core$IFn$_invoke$arity$3(pred,pred_subject,args__$1);\n}\n}\n})())){\nreturn acc;\n} else {\nreturn cljs.core.update_in.cljs$core$IFn$_invoke$arity$3(acc,error_path,(function (p1__65721_SHARP_){\nreturn cljs.core.conj.cljs$core$IFn$_invoke$arity$2(p1__65721_SHARP_,(function (){var G__65735 = new cljs.core.PersistentArrayMap(null, 5, [new cljs.core.Keyword(null,\"path\",\"path\",-188191168),k__$1,new cljs.core.Keyword(null,\"value\",\"value\",305978217),pred_subject,new cljs.core.Keyword(null,\"args\",\"args\",1315556576),cljs.core.seq(args__$1),new cljs.core.Keyword(null,\"metadata\",\"metadata\",1799301597),meta_with_defaults,new cljs.core.Keyword(null,\"message\",\"message\",-406056002),message], null);\nreturn (message_fn.cljs$core$IFn$_invoke$arity$1 ? message_fn.cljs$core$IFn$_invoke$arity$1(G__65735) : message_fn.call(null,G__65735));\n})());\n}));\n}\n} else {\nreturn acc;\n}\n});\n/**\n * Internal Use.\n * \n *   Chain of responsibility.\n * \n *   Takes the current state and a collection of validators `fs`\n * \n *   Will run all validators against `old-state` and eventually return a vector with the result - the errors map - and the new state - the original map augmented with the errors map.\n * \n *   See also `wrap`\n */\nbouncer.core.wrap_chain = (function bouncer$core$wrap_chain(var_args){\nvar args__4742__auto__ = [];\nvar len__4736__auto___65767 = arguments.length;\nvar i__4737__auto___65768 = (0);\nwhile(true){\nif((i__4737__auto___65768 < len__4736__auto___65767)){\nargs__4742__auto__.push((arguments[i__4737__auto___65768]));\n\nvar G__65769 = (i__4737__auto___65768 + (1));\ni__4737__auto___65768 = G__65769;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4743__auto__ = ((((2) < args__4742__auto__.length))?(new cljs.core.IndexedSeq(args__4742__auto__.slice((2)),(0),null)):null);\nreturn bouncer.core.wrap_chain.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4743__auto__);\n});\n\n(bouncer.core.wrap_chain.cljs$core$IFn$_invoke$arity$variadic = (function (old_state,message_fn,fs){\nvar new_state = cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(cljs.core.partial.cljs$core$IFn$_invoke$arity$2(bouncer.core.wrap,message_fn),old_state,fs);\nreturn new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Keyword(\"bouncer.core\",\"errors\",\"bouncer.core/errors\",-444562289).cljs$core$IFn$_invoke$arity$1(new_state),new_state], null);\n}));\n\n(bouncer.core.wrap_chain.cljs$lang$maxFixedArity = (2));\n\n/** @this {Function} */\n(bouncer.core.wrap_chain.cljs$lang$applyTo = (function (seq65736){\nvar G__65737 = cljs.core.first(seq65736);\nvar seq65736__$1 = cljs.core.next(seq65736);\nvar G__65738 = cljs.core.first(seq65736__$1);\nvar seq65736__$2 = cljs.core.next(seq65736__$1);\nvar self__4723__auto__ = this;\nreturn self__4723__auto__.cljs$core$IFn$_invoke$arity$variadic(G__65737,G__65738,seq65736__$2);\n}));\n\n/**\n * Internal use.\n * \n *   Validates the map m using the validation functions fs.\n * \n *   Returns a vector where the first element is the map of validation errors if any and the second is the original map (possibly) augmented with the errors map.\n */\nbouncer.core.validate_STAR_ = (function bouncer$core$validate_STAR_(message_fn,m,fs){\nvar G__65742 = new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [null,m], null);\nvar vec__65743 = G__65742;\nvar errors = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__65743,(0),null);\nvar state = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__65743,(1),null);\nvar ret = vec__65743;\nvar fs__$1 = fs;\nvar G__65742__$1 = G__65742;\nvar fs__$2 = fs__$1;\nwhile(true){\nvar vec__65746 = G__65742__$1;\nvar errors__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__65746,(0),null);\nvar state__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__65746,(1),null);\nvar ret__$1 = vec__65746;\nvar fs__$3 = fs__$2;\nif(cljs.core.seq(fs__$3)){\nvar G__65773 = bouncer.core.wrap_chain.cljs$core$IFn$_invoke$arity$variadic(state__$1,message_fn,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([cljs.core.first(fs__$3)], 0));\nvar G__65774 = cljs.core.rest(fs__$3);\nG__65742__$1 = G__65773;\nfs__$2 = G__65774;\ncontinue;\n} else {\nreturn ret__$1;\n}\nbreak;\n}\n});\n/**\n * Use together with `validate`, e.g.:\n * \n * \n *    (core/validate core/with-default-messages {}\n *                   :name v/required)\n */\nbouncer.core.with_default_messages = (function bouncer$core$with_default_messages(error){\nvar map__65749 = error;\nvar map__65749__$1 = (((((!((map__65749 == null))))?(((((map__65749.cljs$lang$protocol_mask$partition0$ & (64))) || ((cljs.core.PROTOCOL_SENTINEL === map__65749.cljs$core$ISeq$))))?true:false):false))?cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core.hash_map,map__65749):map__65749);\nvar message = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__65749__$1,new cljs.core.Keyword(null,\"message\",\"message\",-406056002));\nvar path = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__65749__$1,new cljs.core.Keyword(null,\"path\",\"path\",-188191168));\nvar metadata = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__65749__$1,new cljs.core.Keyword(null,\"metadata\",\"metadata\",1799301597));\nreturn goog.string.format((function (){var or__4126__auto__ = message;\nif(cljs.core.truth_(or__4126__auto__)){\nreturn or__4126__auto__;\n} else {\nreturn new cljs.core.Keyword(null,\"default-message-format\",\"default-message-format\",179806141).cljs$core$IFn$_invoke$arity$1(metadata);\n}\n})(),cljs.core.name(cljs.core.peek(path)));\n});\n/**\n * Takes a\n * \n *   - `message-fn` (optional) responsible for transforming error metadata into\n *   the validation result (defaults to `with-default-messages`)\n * \n *   - `m` map to be validated\n * \n *   - `forms` validations to be performed on the map\n * \n *   forms can be a single validator set or a sequence of key/value pairs where:\n * \n *   key   ==> :keyword or [:a :path]\n * \n *   value ==> validation-function or\n *          validator-set or\n *         [[validation-function args+opts]] or\n *         [validation-function another-validation-function] or\n *         [validation-function [another-validation-function args+opts]]\n * \n *   e.g.:\n * \n * \n *    (core/validate a-map\n *             :name v/required\n *             :age  [v/required\n *                   [v/number :message \"age must be a number\"]]\n *             [:passport :number] v/positive)\n * \n * \n *   Returns a vector where the first element is the map of validation errors if\n *   any and the second is the original map (possibly) augmented with the errors\n *   map.\n * \n *   See also `defvalidator`\n */\nbouncer.core.validate = (function bouncer$core$validate(var_args){\nvar args__4742__auto__ = [];\nvar len__4736__auto___65775 = arguments.length;\nvar i__4737__auto___65776 = (0);\nwhile(true){\nif((i__4737__auto___65776 < len__4736__auto___65775)){\nargs__4742__auto__.push((arguments[i__4737__auto___65776]));\n\nvar G__65777 = (i__4737__auto___65776 + (1));\ni__4737__auto___65776 = G__65777;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4743__auto__ = ((((0) < args__4742__auto__.length))?(new cljs.core.IndexedSeq(args__4742__auto__.slice((0)),(0),null)):null);\nreturn bouncer.core.validate.cljs$core$IFn$_invoke$arity$variadic(argseq__4743__auto__);\n});\n\n(bouncer.core.validate.cljs$core$IFn$_invoke$arity$variadic = (function (args){\nvar vec__65752 = ((cljs.core.fn_QMARK_(cljs.core.first(args)))?new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.first(args),cljs.core.next(args)], null):new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [bouncer.core.with_default_messages,args], null));\nvar message_fn = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__65752,(0),null);\nvar args__$1 = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__65752,(1),null);\nvar vec__65755 = new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.first(args__$1),cljs.core.next(args__$1)], null);\nvar m = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__65755,(0),null);\nvar forms = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__65755,(1),null);\nreturn bouncer.core.validate_STAR_(message_fn,m,bouncer.core.build_steps(forms));\n}));\n\n(bouncer.core.validate.cljs$lang$maxFixedArity = (0));\n\n/** @this {Function} */\n(bouncer.core.validate.cljs$lang$applyTo = (function (seq65751){\nvar self__4724__auto__ = this;\nreturn self__4724__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq65751));\n}));\n\n/**\n * Takes a map and one or more validation functions with semantics provided by \"validate\". Returns true if the map passes all validations. False otherwise.\n */\nbouncer.core.valid_QMARK_ = (function bouncer$core$valid_QMARK_(var_args){\nvar args__4742__auto__ = [];\nvar len__4736__auto___65778 = arguments.length;\nvar i__4737__auto___65779 = (0);\nwhile(true){\nif((i__4737__auto___65779 < len__4736__auto___65778)){\nargs__4742__auto__.push((arguments[i__4737__auto___65779]));\n\nvar G__65780 = (i__4737__auto___65779 + (1));\ni__4737__auto___65779 = G__65780;\ncontinue;\n} else {\n}\nbreak;\n}\n\nvar argseq__4743__auto__ = ((((0) < args__4742__auto__.length))?(new cljs.core.IndexedSeq(args__4742__auto__.slice((0)),(0),null)):null);\nreturn bouncer.core.valid_QMARK_.cljs$core$IFn$_invoke$arity$variadic(argseq__4743__auto__);\n});\n\n(bouncer.core.valid_QMARK_.cljs$core$IFn$_invoke$arity$variadic = (function (args){\nreturn cljs.core.empty_QMARK_(cljs.core.first(cljs.core.apply.cljs$core$IFn$_invoke$arity$2(bouncer.core.validate,args)));\n}));\n\n(bouncer.core.valid_QMARK_.cljs$lang$maxFixedArity = (0));\n\n/** @this {Function} */\n(bouncer.core.valid_QMARK_.cljs$lang$applyTo = (function (seq65758){\nvar self__4724__auto__ = this;\nreturn self__4724__auto__.cljs$core$IFn$_invoke$arity$variadic(cljs.core.seq(seq65758));\n}));\n\n","~:ns-info",["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:author","Leonardo Borges","~:doc","The `core` namespace provides the two main entry point functions in bouncer:\n\n  - `validate`\n  - `valid?`\n\n\nAll other functions are meant for internal use only and shouldn't be relied upon.\n\nThe project [README](https://github.com/leonardoborges/bouncer/blob/master/README.md) should get you started,\nit's pretty comprehensive.\n\n\nIf you'd like to know more about the motivation behind `bouncer`, check the\n[announcement post](http://www.leonardoborges.com/writings/2013/01/04/bouncer-validation-lib-for-clojure/).","~:file","bouncer/core.cljc","~:line",1,"~:column",5,"~:end-line",1,"~:end-column",17],"~:ns-aliases",["^ ","~$cljs.loader","~$shadow.loader","~$clojure.pprint","~$cljs.pprint","~$clojure.spec.alpha","~$cljs.spec.alpha","~$react","~$module$node_modules$react$index","~$react-dom","~$module$node_modules$react_dom$index","~$clojure.spec.gen.alpha","~$cljs.spec.gen.alpha"],"~:use-macros",null,"~:excludes",["~#set",[]],"~:name","~$bouncer.core","~:op","~:ns","~:imports",null,"~:requires",["^ ","~$goog.string","^S","~$gstring","^S","~$goog.string.format","^U","~$cljs.core","^V","~$goog","^W"],"~:seen",["^L",["~:require"]],"~:uses",null,"~:require-macros",["^ ","^V","^V"],"~:form",["~#list",["~$ns","^N","The `core` namespace provides the two main entry point functions in bouncer:\n\n  - `validate`\n  - `valid?`\n\n\nAll other functions are meant for internal use only and shouldn't be relied upon.\n\nThe project [README](https://github.com/leonardoborges/bouncer/blob/master/README.md) should get you started,\nit's pretty comprehensive.\n\n\nIf you'd like to know more about the motivation behind `bouncer`, check the\n[announcement post](http://www.leonardoborges.com/writings/2013/01/04/bouncer-validation-lib-for-clojure/).",["^ ","^6","Leonardo Borges"],["^11",["^Y",["^S","~:as","^T"],["^U"]]]]],"~:flags",["^ ","^Y",["^L",[]]],"~:js-deps",["^ "],"~:deps",["^W","^V","^S","^U"]],"^P","^N","~:resource-id",["~:shadow.build.classpath/resource","bouncer/core.cljc"],"~:compiled-at",1623240914255,"~:resource-name","bouncer/core.cljc","~:warnings",[],"~:source","(ns bouncer.core\n  \"The `core` namespace provides the two main entry point functions in bouncer:\n\n  - `validate`\n  - `valid?`\n\n\nAll other functions are meant for internal use only and shouldn't be relied upon.\n\nThe project [README](https://github.com/leonardoborges/bouncer/blob/master/README.md) should get you started,\nit's pretty comprehensive.\n\n\nIf you'd like to know more about the motivation behind `bouncer`, check the\n[announcement post](http://www.leonardoborges.com/writings/2013/01/04/bouncer-validation-lib-for-clojure/).\"\n  {:author \"Leonardo Borges\"}\n  #?(:cljs (:require [goog.string :as gstring]\n                     [goog.string.format])))\n\n\n\n;; ## Internal utility functions\n\n(defn- build-multi-step\n  ([key-or-vec fn-vec] (build-multi-step key-or-vec fn-vec []))\n  ([key-or-vec [f-or-list & rest] acc]\n   (if-not f-or-list\n     acc\n     (cond\n       (sequential? f-or-list)\n       (let [[f & opts] f-or-list]\n         (recur key-or-vec\n                rest\n                (conj acc (concat [f key-or-vec] opts))))\n\n       :else (recur key-or-vec\n                    rest\n                    (conj acc [f-or-list key-or-vec]))))))\n\n(defn- merge-path\n  \"Takes two arguments:\n\n  `parent-keyword` is a :keyword - or a vector of :keywords denoting a path in a associative structure\n\n  `validations-map` is a map of forms following this spec:\n\n\n      {:keyword [f g] :another-keyword h}\n\n\n  Merges `:parent-keyword` with every first element of validations-map, transforming it into:\n\n\n      ([:parent-keyword :keyword] [f g] [:parent-keyword :another-keyword] h)\n\"\n  [parent-key validations-map]\n  (let [parent-key (if (keyword? parent-key) [parent-key] parent-key)]\n    (mapcat (fn [[key validations]]\n              (if (vector? key)\n                [(apply vector (concat parent-key key)) validations]\n                [(apply vector (concat parent-key [key])) validations]))\n            validations-map)))\n\n(defn- build-steps [[head & tail :as forms]]\n  (let [forms (if (map? head)\n                (vec (mapcat identity head))\n                forms)]\n    (reduce (fn [acc [key-or-vec sym-or-coll :as rule]]\n              (cond\n                (vector? sym-or-coll)\n                (concat acc (build-multi-step key-or-vec sym-or-coll))\n\n\n                (map? sym-or-coll)\n                (concat acc (build-steps (merge-path key-or-vec\n                                                     sym-or-coll)))\n\n                :else (conj acc [sym-or-coll key-or-vec])))\n            []\n            (partition 2 forms))))\n\n(defn- pre-condition-met? [pre-fn map]\n  (or (nil? pre-fn) (pre-fn map)))\n\n(defn- wrap\n  \"Wraps pred in the context of validating a single value\n\n  - `acc`  is the map being validated\n\n  - `pred` is a validator\n\n  - `k`    the path to the value to be validated in the associative structure `acc`\n\n  - `args` any extra args to pred\n\n  It only runs pred if:\n\n  - the validator contains a pre-condition *and* it is met or;\n  - the validator is optional  *and* there is a non-nil value to be validated (this information is read from pred's metadata) or;\n  - there are no previous errors for the given path\n\n  Returns `acc` augmented with a namespace qualified ::errors keyword\n\"\n  [message-fn acc [pred k & args]]\n  (let [k            (if (vector? k) k [k])\n        error-path   (cons ::errors k)\n\n        {:keys [optional default-message-format]\n         :or   {optional               false\n                default-message-format \"Custom validation failed for %s\"}\n         :as   metadata} (meta pred)\n\n        meta-with-defaults\n                     (merge metadata {:default-message-format default-message-format\n                                      :optional               optional})\n\n        [args opts] (split-with (complement keyword?) args)\n        {:keys [message pre]} (apply hash-map opts)\n        pred-subject (get-in acc k)]\n    (if (pre-condition-met? pre acc)\n      (if (or (and optional (nil? pred-subject))\n              (not (empty? (get-in acc error-path)))\n              (apply pred pred-subject args))\n        acc\n        (update-in acc error-path\n                   #(conj % (message-fn {:path     k, :value pred-subject\n                                         :args     (seq args)\n                                         :metadata meta-with-defaults\n                                         :message  message}))))\n      acc)))\n\n\n(defn- wrap-chain\n  \"Internal Use.\n\n  Chain of responsibility.\n\n  Takes the current state and a collection of validators `fs`\n\n  Will run all validators against `old-state` and eventually return a vector with the result - the errors map - and the new state - the original map augmented with the errors map.\n\n  See also `wrap`\n\"\n  [old-state message-fn & fs]\n  (let [new-state (reduce (partial wrap message-fn)\n                          old-state\n                          fs)]\n    [(::errors new-state) new-state]))\n\n(defn- validate*\n  \"Internal use.\n\n  Validates the map m using the validation functions fs.\n\n  Returns a vector where the first element is the map of validation errors if any and the second is the original map (possibly) augmented with the errors map.\"\n  [message-fn m fs]\n  (loop [[errors state :as ret] [nil m]\n         fs fs]\n    (if (seq fs)\n      (recur (wrap-chain state message-fn (first fs)) (rest fs))\n      ret)))\n\n;; ## Public API\n\n(defn with-default-messages\n  \"Use together with `validate`, e.g.:\n\n\n      (core/validate core/with-default-messages {}\n                     :name v/required)\"\n  [error]\n  (let [{:keys [message path metadata]} error]\n    #?(:clj (format (or message (:default-message-format metadata))\n                    (name (peek path))))\n    #?(:cljs (gstring/format (or message (:default-message-format metadata))\n                             (name (peek path))))))\n\n(defn validate\n  \"Takes a\n\n  - `message-fn` (optional) responsible for transforming error metadata into\n  the validation result (defaults to `with-default-messages`)\n\n  - `m` map to be validated\n\n  - `forms` validations to be performed on the map\n\n  forms can be a single validator set or a sequence of key/value pairs where:\n\n  key   ==> :keyword or [:a :path]\n\n  value ==> validation-function or\n            validator-set or\n           [[validation-function args+opts]] or\n           [validation-function another-validation-function] or\n           [validation-function [another-validation-function args+opts]]\n\n  e.g.:\n\n\n      (core/validate a-map\n               :name v/required\n               :age  [v/required\n                     [v/number :message \\\"age must be a number\\\"]]\n               [:passport :number] v/positive)\n\n\n  Returns a vector where the first element is the map of validation errors if\n  any and the second is the original map (possibly) augmented with the errors\n  map.\n\n  See also `defvalidator`\n\"\n  [& args]\n  (let [[message-fn args] (if (fn? (first args))\n                            [(first args) (next args)]\n                            [with-default-messages args])\n        [m forms] [(first args) (next args)]]\n    (validate* message-fn m (build-steps forms))))\n\n(defn valid?\n  \"Takes a map and one or more validation functions with semantics provided by \\\"validate\\\". Returns true if the map passes all validations. False otherwise.\"\n  [& args]\n  (empty? (first (apply validate args))))\n","~:reader-features",["^L",["~:cljs"]],"~:cljc",true,"~:source-map-compact",["^ ","mappings",";AAuBA,AAAA,AAAA,AAAAA,AAAOE;AAAP,AAAA,AAAAD,AAAA,AAAA;AAAA,AAAA,AAAAA;AAAA;AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;;;AAAA;AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA;;;;AAAA,AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA;;;;;AAAA,AAAA,AAAA,AAAOD,AACHS,AAAWC;AADf,AACuB,AAAA,AAACC,AAAiBF,AAAWC;;;AADpD,AAAA,AAAA,AAAAR,AAAOF,AAEHS,AAA8BK;;AAFlC,AAAA,AAAAX,AAAAD;AAAAE,AAAA,AAAAC,AAAAF;AAAAG,AAAA,AAAAC,AAAAH;AAAAA,AAAA,AAAAI,AAAAJ;AAAAE,AAEgBM;AAFhBR,AAE4BS;AAF5B,AAGG,AAAA,AAAAE,AAAQH;AACNE;;AACA,AACE,AAACE,AAAYJ;AACb,AAAAK,AAAiBL;AAAjBM,AAAA,AAAAb,AAAAY;AAAAE,AAAA,AAAAZ,AAAAW;AAAAA,AAAA,AAAAV,AAAAU;AAAAC,AAAOC;AAAPF,AAAWG;AAAX,AACE,AAAOZ;AACAI;AACA,AAACS,AAAKR,AAAI,AAAA,AAACS,AAAQH,AAAEX,AAAYY;;;;;;AAL5C,AAOQ,AAAOZ;AACAI;AACA,AAAA,AAACS,AAAKR,AAAKF,AAAUH;;;;;;;;;;;;AAdzC,AAAA,AAAA,AAAOT;;AAAP,AAgBA;;;;;;;;;;;;;;;;AAAA,AAAOwB,AAgBJC,AAAWC;AAhBd,AAiBE,AAAMD,AAAW,AAAA,AAAI,AAAAE,AAAUF,AAAaA,AAAYA;AAAxD,AACE,AAACG,AAAO,AAAAC;AAAA,AAAA,AAAAC,AAAAD;AAAA,AAAAE,AAAAD,AAAA,AAAA,AAAME;AAAN,AAAAD,AAAAD,AAAA,AAAA,AAAUG;AAAV,AACE,AAAI,AAACC,AAAQF;AAAb,AACG,AAACG,AAAMC,AAAO,AAACb,AAAOE,AAAWO,AAAMC;;AAD1C,AAEG,AAACE,AAAMC,AAAO,AAAA,AAACb,AAAOE,AAAYO,AAAOC;;AAC9CP;;AAEZ,AAAA,AAAAW,AAAOI;AAAP,AAAA,AAAAH,AAAAD;AAAAE,AAAA,AAAAlC,AAAAiC;AAAAE,AAAA,AAAAjC,AAAAgC;AAAAA,AAAA,AAAA/B,AAAA+B;AAAAC,AAAqBE;AAArBH,AAA4BI;AAA5BL,AAAqCM;AAArC,AACE,AAAMA,AAAM,AAAI,AAACC,AAAKH,AACR,AAACI,AAAI,AAAClB,AAAOmB,AAASL,AACtBE;AAFd,AAGE,AAACI,AAAO,AAAAC,AAAKnC;AAAL,AAAA,AAAAoC,AAAAD;AAAA,AAAAlB,AAAAmB,AAAA,AAAA,AAAUzC;AAAV,AAAAsB,AAAAmB,AAAA,AAAA,AAAqBC;AAArBD,AAAqCE;AAArC,AACE,AACE,AAAClB,AAAQiB;AACT,AAAC5B,AAAOT,AAAI,AAACH,AAAiBF,AAAW0C;;AAF3C,AAKE,AAACN,AAAKM;AACN,AAAC5B,AAAOT,AAAI,AAAAuC,AAAa,AAAC7B,AAAWf,AACA0C;AADzB,AAAA,AAAAE,AAAAA,AAACZ,AAAAA,AAAAA;;;AANf,AASQ,AAAA,AAACnB,AAAKR,AAAKqC,AAAY1C;;;;AAVzC,AAYQ,AAAA,AAAC6C,AAAYV;;AAEzB,AAAA,AAAOW,AAAoBC,AAAOC;AAAlC,AACE,AAAAC,AAAI,AAAA,AAAMF;AAAV,AAAA,AAAAE;AAAAA;;AAAkB,AAACF,AAAAA,AAAAA,AAAOC,AAAAA;;;AAE5B;;;;;;;;;;;;;;;;;;;AAAA,AAAAE,AAAOI,AAmBJC,AAAWlD;AAnBd,AAAA,AAAA8C,AAAAD;AAAAE,AAAA,AAAAxD,AAAAuD;AAAAE,AAAA,AAAAvD,AAAAsD;AAAAA,AAAA,AAAArD,AAAAqD;AAAAC,AAmBmBG;AAnBnBH,AAAA,AAAAvD,AAAAsD;AAAAA,AAAA,AAAArD,AAAAqD;AAAAC,AAmBwBI;AAnBxBL,AAmB4BM;AAnB5B,AAoBE,AAAMD,AAAa,AAAA,AAAI,AAAChC,AAAQgC,AAAGA,AAAGA;AAChCQ,AAAa,AAAA,AAACC,AAAcT;AADlCE,AAMuB,AAACW,AAAKd;AAN7BG,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAC,AAAA,AAAAD,AAAA,AAAA,AAAA,AAAA,AAAAjC,AAAAmC,AAAAF,AAAAA;AAAAA,AAMaU;AANb,AAAAP,AAAAH,AAAA,AAAA,AAGcQ;AAHd,AAAAL,AAAAH,AAAA,AAAA,AAGuBS;AAKjBG,AACa,AAAA,AAAA,AAAA,AAACC,AAAMH,AAAkCD,AACAD;AAV5DJ,AAYkB,AAACU,AAAW,AAACC,AAAWC,AAAUjB;AAZpD,AAAApC,AAAAyC,AAAA,AAAA,AAYOL;AAZP,AAAApC,AAAAyC,AAAA,AAAA,AAYYnD;AAZZoD,AAa4B,AAACtC,AAAMmC,AAASjD;AAb5CoD,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAJ,AAAA,AAAAI,AAAA,AAAA,AAAA,AAAA,AAAAtC,AAAAmC,AAAAG,AAAAA;AAAA,AAAAF,AAAAE,AAAA,AAacY;AAbd,AAAAd,AAAAE,AAAA,AAasBa;AAChBC,AAAa,AAACC,AAAO1E,AAAIoD;AAd/B,AAeE,AAAI,AAACX,AAAmB+B,AAAIxE;AAC1B,AAAI,AAAA4C,AAAI,AAAA+B,AAAKb;AAAL,AAAA,AAAAa;AAAc,AAAA,AAAMF;;AAApBE;;;AAAJ,AAAA,AAAA/B;AAAAA;;AAAA,AAAAA,AACI,AAAK,AAACgC,AAAO,AAACF,AAAO1E,AAAI4D;AAD7B,AAAA,AAAAhB;AAAAA;;AAEI,AAACvB,AAAM8B,AAAKsB,AAAapB;;;;AAC/BrD;;AACA,AAAA,AAAA6E,AAACC,AAAU9E,AAAI4D;AAAf,AACY,AAAAiB,AAACrE,AAAO,AAAAuE,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAuB3B,AAAUqB,AACV,AAAClF,AAAI8D,AACLa,AACAK;AAHvB,AAAA,AAAAQ,AAAAA,AAAC7B,AAAAA,AAAAA;;;;;AAIvBlD;;;AAGN,AAAA;;;;;;;;;;;AAAA,AAAAhB,AAAOqG;AAAP,AAAA,AAAAL,AAAA;AAAA,AAAA,AAAAC,AAAA,AAAA;AAAA,AAAA,AAAAC,AAAA;;AAAA,AAAA,AAAA,AAAAA,AAAAD;AAAA,AAAA,AAAAD,AAAA,AAAA,AAAAE;;AAAA,AAAA,AAAAA,AAAA;;;;AAAA;;;;AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAAH,AAAA,AAAA,AAAAI,AAAA,AAAAJ,AAAA,AAAA,AAAA,AAAA;AAAA,AAAA,AAAAK,AAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAF;;;AAAA,AAAA,AAAA,AAAA,AAAOE,AAWJK,AAAUxC,AAAayC;AAX1B,AAYE,AAAMC,AAAU,AAAC1D,AAAO,AAAC2D,AAAQ5C,AAAKC,AACdwC,AACAC;AAFxB,AAAA,AAGG,AAAA,AAAUC,AAAWA;;;AAf1B,AAAA,AAAA,AAAOP;;AAAP;AAAA,AAAA,AAAA,AAAAC,AAAOD;AAAP,AAAA,AAAAE,AAAA,AAAA9F,AAAA6F;AAAAA,AAAA,AAAA5F,AAAA4F;AAAAE,AAAA,AAAA/F,AAAA6F;AAAAA,AAAA,AAAA5F,AAAA4F;AAAA,AAAA,AAAAG,AAAA;AAAA,AAAA,AAAAA,AAAAF,AAAAC,AAAAF;;;AAAA,AAiBA;;;;;;;AAAA,AAAOQ,AAMJ5C,AAAW6C,AAAEJ;AANhB,AAOE,AAAAK,AAAA,AAAA,AAAmCD;AAAnCE,AAAAD;AAAA,AAAA/E,AAAAgF,AAAA,AAAA,AAAQE;AAAR,AAAAlF,AAAAgF,AAAA,AAAA,AAAeG;AAAfH,AAAyBI;AAClBV,AAAGA;AADV,AAAA,AAAAK,AAAAA;AACOL,AAAAA;;AADP,AAAA,AAAAO,AAAAF;AAAA,AAAA/E,AAAAiF,AAAA,AAAA,AAAQC;AAAR,AAAAlF,AAAAiF,AAAA,AAAA,AAAeE;AAAfF,AAAyBG;AAClBV,AAAAA;AADP,AAEE,AAAI,AAACpG,AAAIoG;AACP,AAAO,AAACW,AAAWF,AAAMlD,AAAW,AAACzD,AAAMkG;AAAK,AAACY,AAAKZ;;;;;AACtDU;;;;;AAIN;;;;;;;AAAA,AAAMG,AAMHC;AANH,AAOE,AAAAC,AAAsCD;AAAtCC,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAA,AAAA,AAAA,AAAAA,AAAA,AAAA,AAAAnD,AAAA,AAAAmD,AAAA,AAAA,AAAA,AAAA,AAAArF,AAAAmC,AAAAkD,AAAAA;AAAA,AAAAjD,AAAAiD,AAAA,AAAcnC;AAAd,AAAAd,AAAAiD,AAAA,AAAsBC;AAAtB,AAAAlD,AAAAiD,AAAA,AAA2B1C;AAA3B,AAGW,AAAC4C,AAAe,AAAAhE,AAAI2B;AAAJ,AAAA,AAAA3B;AAAAA;;AAAY,AAAA,AAAyBoB;;AACrC,AAAC6C,AAAK,AAACC,AAAKH;;AAEzC,AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,AAAA3H,AAAM+H;AAAN,AAAA,AAAA/B,AAAA;AAAA,AAAA,AAAAC,AAAA,AAAA;AAAA,AAAA,AAAAC,AAAA;;AAAA,AAAA,AAAA,AAAAA,AAAAD;AAAA,AAAA,AAAAD,AAAA,AAAA,AAAAE;;AAAA,AAAA,AAAAA,AAAA;;;;AAAA;;;;AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAAH,AAAA,AAAA,AAAAI,AAAA,AAAAJ,AAAA,AAAA,AAAA,AAAA;AAAA,AAAA,AAAA+B,AAAA5B;;;AAAA,AAAA,AAAA,AAAA,AAAM4B,AAoCD1D;AApCL,AAqCE,AAAA6D,AAAwB,AAAA,AAAA,AAAI,AAACE,AAAI,AAAC3H,AAAM4D,AACb,AAAC5D,AAAM4D,AAAM,AAAC3D,AAAK2D,AACnBmD,AAAsBnD;AAFjD,AAAApC,AAAAiG,AAAA,AAAA,AAAOhE;AAAP,AAAAjC,AAAAiG,AAAA,AAAA,AAAkB7D;AAAlB8D,AAAA,AAGiB,AAAC1H,AAAM4D,AAAM,AAAC3D,AAAK2D;AAHpC,AAAApC,AAAAkG,AAAA,AAAA,AAGOpB;AAHP,AAAA9E,AAAAkG,AAAA,AAAA,AAGSrF;AAHT,AAIE,AAACgE,AAAU5C,AAAW6C,AAAE,AAACpE,AAAYG;;;AAzCzC,AAAA,AAAA,AAAMiF;;AAAN;AAAA,AAAA,AAAA,AAAAC,AAAMD;AAAN,AAAA,AAAAE,AAAA;AAAA,AAAA,AAAAA,AAAA,AAAA1H,AAAAyH;;;AAAA,AA2CA,AAAA;;;AAAA,AAAAhI,AAAMqI;AAAN,AAAA,AAAArC,AAAA;AAAA,AAAA,AAAAC,AAAA,AAAA;AAAA,AAAA,AAAAC,AAAA;;AAAA,AAAA,AAAA,AAAAA,AAAAD;AAAA,AAAA,AAAAD,AAAA,AAAA,AAAAE;;AAAA,AAAA,AAAAA,AAAA;;;;AAAA;;;;AAAA,AAAAC,AAAA,AAAA,AAAA,AAAA,AAAAH,AAAA,AAAA,AAAAI,AAAA,AAAAJ,AAAA,AAAA,AAAA,AAAA;AAAA,AAAA,AAAAqC,AAAAlC;;;AAAA,AAAA,AAAA,AAAA,AAAMkC,AAEDhE;AAFL,AAGE,AAACuB,AAAO,AAACnF,AAAM,AAAC4B,AAAM0F,AAAS1D;;;AAHjC,AAAA,AAAA,AAAMgE;;AAAN;AAAA,AAAA,AAAA,AAAAC,AAAMD;AAAN,AAAA,AAAAJ,AAAA;AAAA,AAAA,AAAAA,AAAA,AAAA1H,AAAA+H;;;AAAA","names",["var_args","G__65689","bouncer.core/build-multi-step","js/Error","p__65694","vec__65695","seq__65696","cljs.core/seq","first__65697","cljs.core/first","cljs.core/next","key-or-vec","fn-vec","bouncer.core.build_multi_step","f-or-list","rest","acc","cljs.core/not","cljs.core/sequential?","vec__65698","seq__65699","first__65700","f","opts","cljs.core.conj","cljs.core.concat","bouncer.core/merge-path","parent-key","validations-map","cljs.core/Keyword","cljs.core.mapcat","p__65703","vec__65704","cljs.core.nth","key","validations","cljs.core/vector?","cljs.core.apply","cljs.core/vector","p__65711","vec__65712","seq__65713","first__65714","bouncer.core/build-steps","head","tail","forms","cljs.core/map?","cljs.core/vec","cljs.core/identity","cljs.core.reduce","p__65716","vec__65717","sym-or-coll","rule","G__65720","cljs.core.partition","bouncer.core/pre-condition-met?","pre-fn","map","or__4126__auto__","p__65722","vec__65723","seq__65724","first__65725","bouncer.core/wrap","message-fn","pred","k","args","map__65726","cljs.core/PROTOCOL_SENTINEL","cljs.core/hash-map","cljs.core.get","vec__65727","map__65730","error-path","cljs.core/cons","optional","default-message-format","metadata","cljs.core/meta","meta-with-defaults","cljs.core.merge","cljs.core/split-with","cljs.core/complement","cljs.core/keyword?","message","pre","pred-subject","cljs.core.get_in","and__4115__auto__","cljs.core/empty?","p1__65721#","cljs.core.update_in","G__65735","args__4742__auto__","len__4736__auto__","i__4737__auto__","argseq__4743__auto__","cljs.core/IndexedSeq","bouncer.core/wrap-chain","seq65736","G__65737","G__65738","self__4723__auto__","old-state","fs","new-state","cljs.core.partial","bouncer.core/validate*","m","G__65742","vec__65743","vec__65746","errors","state","ret","bouncer.core.wrap_chain","cljs.core/rest","bouncer.core/with-default-messages","error","map__65749","path","goog.string/format","cljs.core/name","cljs.core/peek","bouncer.core/validate","seq65751","self__4724__auto__","vec__65752","vec__65755","cljs.core/fn?","bouncer.core/valid?","seq65758"]],"~:used-vars",["^L",["~$cljs.core/mapcat","~$cljs.core/rest","~$cljs.core/sequential?","~$bouncer.core/wrap-chain","~$cljs.core/vector?","~$bouncer.core/merge-path","~$cljs.core/reduce","~$cljs.core/seq","~$cljs.core/apply","~$goog.string/format","~$bouncer.core/validate*","~$cljs.core/concat","~$bouncer.core/validate","~$cljs.core/empty?","~$cljs.core/map?","~$cljs.core/conj","~$bouncer.core/build-multi-step","~$cljs.core/peek","~$bouncer.core/valid?","~$cljs.core/partition","~$bouncer.core/wrap","~$bouncer.core/pre-condition-met?","~$cljs.core/not","~$bouncer.core/build-steps","~$cljs.core/first","~$cljs.core/name","~$cljs.core/update-in","~$js/Error","~$cljs.core/vector","~$bouncer.core/with-default-messages"]]],"~:cache-keys",["~#cmap",[["^18","goog/dom/tagname.js"],["6025affb7181cd40418600864f58eed1ea80055d","~:shadow.build.compiler/resolve",["^ ","~:require-id",null,"~:deps-ids",["^L",[]],"~:deps-syms",["^W","~$goog.dom.HtmlElement"]]],["^18","goog/math/math.js"],["6025affb7181cd40418600864f58eed1ea80055d","^28",["^ ","^29",null,"^2:",["^L",[]],"^2;",["^W","~$goog.array","~$goog.asserts"]]],["^18","goog/html/trustedtypes.js"],["6025affb7181cd40418600864f58eed1ea80055d","^28",["^ ","^29",null,"^2:",["^L",[]],"^2;",["^W"]]],["^18","goog/string/stringformat.js"],["6025affb7181cd40418600864f58eed1ea80055d","^28",["^ ","^29",null,"^2:",["^L",[]],"^2;",["^W","^S"]]],["^18","goog/labs/useragent/browser.js"],["6025affb7181cd40418600864f58eed1ea80055d","^28",["^ ","^29",null,"^2:",["^L",[]],"^2;",["^W","^2=","~$goog.labs.userAgent.util","~$goog.object","~$goog.string.internal"]]],["^18","goog/html/safeurl.js"],["6025affb7181cd40418600864f58eed1ea80055d","^28",["^ ","^29",null,"^2:",["^L",[]],"^2;",["^W","^2>","~$goog.fs.url","~$goog.html.TrustedResourceUrl","~$goog.i18n.bidi.Dir","~$goog.i18n.bidi.DirectionalString","~$goog.string.Const","~$goog.string.TypedString","^2A"]]],["^18","goog/array/array.js"],["6025affb7181cd40418600864f58eed1ea80055d","^28",["^ ","^29",null,"^2:",["^L",[]],"^2;",["^W","^2>"]]],["^18","goog/debug/error.js"],["6025affb7181cd40418600864f58eed1ea80055d","^28",["^ ","^29",null,"^2:",["^L",[]],"^2;",["^W"]]],["^18","goog/dom/nodetype.js"],["6025affb7181cd40418600864f58eed1ea80055d","^28",["^ ","^29",null,"^2:",["^L",[]],"^2;",["^W"]]],["^18","goog/string/typedstring.js"],["6025affb7181cd40418600864f58eed1ea80055d","^28",["^ ","^29",null,"^2:",["^L",[]],"^2;",["^W"]]],["^18","goog/object/object.js"],["6025affb7181cd40418600864f58eed1ea80055d","^28",["^ ","^29",null,"^2:",["^L",[]],"^2;",["^W"]]],["^18","goog/dom/asserts.js"],["6025affb7181cd40418600864f58eed1ea80055d","^28",["^ ","^29",null,"^2:",["^L",[]],"^2;",["^W","^2>"]]],"~:SHADOW-TIMESTAMP",[1619013417000,1619013417000,1615476662000],["^18","goog/math/long.js"],["6025affb7181cd40418600864f58eed1ea80055d","^28",["^ ","^29",null,"^2:",["^L",[]],"^2;",["^W","^2>","~$goog.reflect"]]],["^18","goog/html/trustedresourceurl.js"],["6025affb7181cd40418600864f58eed1ea80055d","^28",["^ ","^29",null,"^2:",["^L",[]],"^2;",["^W","^2>","~$goog.html.trustedtypes","^2D","^2E","^2F","^2G"]]],["^18","goog/string/internal.js"],["6025affb7181cd40418600864f58eed1ea80055d","^28",["^ ","^29",null,"^2:",["^L",[]],"^2;",["^W"]]],["^18","bouncer/core.cljc"],["3000f8d5bf761abc44ce8d2fdaec4bc900147463","^28",["^ ","^29",null,"^2:",["^L",[]],"^2;",["^W","^V","^S","^U"]]],["^18","goog/functions/functions.js"],["6025affb7181cd40418600864f58eed1ea80055d","^28",["^ ","^29",null,"^2:",["^L",[]],"^2;",["^W"]]],["^18","goog/html/safestyle.js"],["6025affb7181cd40418600864f58eed1ea80055d","^28",["^ ","^29",null,"^2:",["^L",[]],"^2;",["^W","^2=","^2>","~$goog.html.SafeUrl","^2F","^2G","^2A"]]],["^18","goog/dom/safe.js"],["6025affb7181cd40418600864f58eed1ea80055d","^28",["^ ","^29",null,"^2:",["^L",[]],"^2;",["^W","^2>","~$goog.dom.asserts","~$goog.functions","~$goog.html.SafeHtml","~$goog.html.SafeScript","~$goog.html.SafeStyle","^2K","^2C","~$goog.html.uncheckedconversions","^2F","^2A"]]],["^18","goog/structs/map.js"],["6025affb7181cd40418600864f58eed1ea80055d","^28",["^ ","^29",null,"^2:",["^L",[]],"^2;",["^W","~$goog.iter.Iterator","~$goog.iter.StopIteration"]]],["^18","goog/html/safehtml.js"],["6025affb7181cd40418600864f58eed1ea80055d","^28",["^ ","^29",null,"^2:",["^L",[]],"^2;",["^W","^2=","^2>","~$goog.dom.TagName","~$goog.dom.tags","^2O","^2P","~$goog.html.SafeStyleSheet","^2K","^2C","^2J","^2D","^2E","~$goog.labs.userAgent.browser","^2@","^2F","^2G","^2A"]]],["^18","goog/dom/tags.js"],["6025affb7181cd40418600864f58eed1ea80055d","^28",["^ ","^29",null,"^2:",["^L",[]],"^2;",["^W","^2@"]]],["^18","goog/asserts/asserts.js"],["6025affb7181cd40418600864f58eed1ea80055d","^28",["^ ","^29",null,"^2:",["^L",[]],"^2;",["^W","~$goog.debug.Error","~$goog.dom.NodeType"]]],["^18","goog/uri/uri.js"],["6025affb7181cd40418600864f58eed1ea80055d","^28",["^ ","^29",null,"^2:",["^L",[]],"^2;",["^W","^2=","^2>","^S","~$goog.structs","~$goog.structs.Map","~$goog.uri.utils","~$goog.uri.utils.ComponentIndex","~$goog.uri.utils.StandardQueryParam"]]],["^18","goog/i18n/bidi.js"],["6025affb7181cd40418600864f58eed1ea80055d","^28",["^ ","^29",null,"^2:",["^L",[]],"^2;",["^W"]]],["^18","goog/fs/url.js"],["6025affb7181cd40418600864f58eed1ea80055d","^28",["^ ","^29",null,"^2:",["^L",[]],"^2;",["^W"]]],["^18","goog/base.js"],["6025affb7181cd40418600864f58eed1ea80055d","^28",["^ ","^29",null,"^2:",["^L",[]],"^2;",[]]],["^18","goog/structs/structs.js"],["6025affb7181cd40418600864f58eed1ea80055d","^28",["^ ","^29",null,"^2:",["^L",[]],"^2;",["^W","^2=","^2@"]]],["^18","goog/string/string.js"],["6025affb7181cd40418600864f58eed1ea80055d","^28",["^ ","^29",null,"^2:",["^L",[]],"^2;",["^W","~$goog.dom.safe","^2Q","^2F","^2A"]]],["^18","goog/reflect/reflect.js"],["6025affb7181cd40418600864f58eed1ea80055d","^28",["^ ","^29",null,"^2:",["^L",[]],"^2;",["^W"]]],["^18","goog/labs/useragent/util.js"],["6025affb7181cd40418600864f58eed1ea80055d","^28",["^ ","^29",null,"^2:",["^L",[]],"^2;",["^W","^2A"]]],["^18","goog/string/stringbuffer.js"],["6025affb7181cd40418600864f58eed1ea80055d","^28",["^ ","^29",null,"^2:",["^L",[]],"^2;",["^W"]]],["^18","goog/iter/iter.js"],["6025affb7181cd40418600864f58eed1ea80055d","^28",["^ ","^29",null,"^2:",["^L",[]],"^2;",["^W","^2=","^2>","^2M","~$goog.math"]]],["^18","goog/html/uncheckedconversions.js"],["6025affb7181cd40418600864f58eed1ea80055d","^28",["^ ","^29",null,"^2:",["^L",[]],"^2;",["^W","^2>","^2N","^2O","^2P","^2V","^2K","^2C","^2F","^2A"]]],["^18","goog/dom/htmlelement.js"],["6025affb7181cd40418600864f58eed1ea80055d","^28",["^ ","^29",null,"^2:",["^L",[]],"^2;",["^W"]]],["^18","cljs/core.cljs"],["9f9729dbbf9b814c83dc189977b447d2ae92b6cd","^28",["^ ","^29",null,"^2:",["^L",[]],"^2;",["^W","~$goog.math.Long","~$goog.math.Integer","^S","^2@","^2=","~$goog.Uri","~$goog.string.StringBuffer"]]],["^18","goog/html/safescript.js"],["6025affb7181cd40418600864f58eed1ea80055d","^28",["^ ","^29",null,"^2:",["^L",[]],"^2;",["^W","^2>","^2J","^2F","^2G"]]],["^18","goog/html/safestylesheet.js"],["6025affb7181cd40418600864f58eed1ea80055d","^28",["^ ","^29",null,"^2:",["^L",[]],"^2;",["^W","^2=","^2>","^2P","^2@","^2F","^2G","^2A"]]],["^18","goog/math/integer.js"],["6025affb7181cd40418600864f58eed1ea80055d","^28",["^ ","^29",null,"^2:",["^L",[]],"^2;",["^W","^2I"]]],["^18","goog/uri/utils.js"],["6025affb7181cd40418600864f58eed1ea80055d","^28",["^ ","^29",null,"^2:",["^L",[]],"^2;",["^W","^2=","^2>","^S"]]],["^18","goog/string/const.js"],["6025affb7181cd40418600864f58eed1ea80055d","^28",["^ ","^29",null,"^2:",["^L",[]],"^2;",["^W","^2>","^2G"]]]]],"~:clj-info",["^ ","jar:file:/home/zeinab/.m2/repository/org/clojure/tools.reader/1.3.2/tools.reader-1.3.2.jar!/clojure/tools/reader/impl/inspect.clj",1612959675000,"jar:file:/home/zeinab/.m2/repository/org/clojure/tools.reader/1.3.2/tools.reader-1.3.2.jar!/clojure/tools/reader/default_data_readers.clj",1612959675000,"jar:file:/home/zeinab/.m2/repository/org/clojure/clojurescript/1.10.773/clojurescript-1.10.773.jar!/cljs/analyzer.cljc",1615476662000,"jar:file:/home/zeinab/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/string.clj",1614164416000,"jar:file:/home/zeinab/.m2/repository/org/clojure/clojurescript/1.10.773/clojurescript-1.10.773.jar!/cljs/source_map/base64.clj",1615476662000,"jar:file:/home/zeinab/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/core.clj",1614164416000,"jar:file:/home/zeinab/.m2/repository/org/clojure/tools.reader/1.3.2/tools.reader-1.3.2.jar!/clojure/tools/reader.clj",1612959675000,"jar:file:/home/zeinab/.m2/repository/org/clojure/tools.reader/1.3.2/tools.reader-1.3.2.jar!/clojure/tools/reader/impl/errors.clj",1612959675000,"jar:file:/home/zeinab/.m2/repository/org/clojure/clojurescript/1.10.773/clojurescript-1.10.773.jar!/cljs/util.cljc",1615476662000,"jar:file:/home/zeinab/.m2/repository/org/clojure/clojurescript/1.10.773/clojurescript-1.10.773.jar!/cljs/compiler.cljc",1615476662000,"jar:file:/home/zeinab/.m2/repository/org/clojure/clojurescript/1.10.773/clojurescript-1.10.773.jar!/cljs/js_deps.cljc",1615476662000,"jar:file:/home/zeinab/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/set.clj",1614164416000,"jar:file:/home/zeinab/.m2/repository/org/clojure/clojurescript/1.10.773/clojurescript-1.10.773.jar!/cljs/source_map.clj",1615476662000,"jar:file:/home/zeinab/.m2/repository/org/clojure/clojurescript/1.10.773/clojurescript-1.10.773.jar!/cljs/env.cljc",1615476662000,"jar:file:/home/zeinab/.m2/repository/org/clojure/data.json/0.2.6/data.json-0.2.6.jar!/clojure/data/json.clj",1612959676000,"jar:file:/home/zeinab/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/edn.clj",1614164416000,"jar:file:/home/zeinab/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/instant.clj",1614164416000,"jar:file:/home/zeinab/.m2/repository/org/clojure/clojurescript/1.10.773/clojurescript-1.10.773.jar!/cljs/core.cljc",1615476662000,"jar:file:/home/zeinab/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/java/io.clj",1614164416000,"jar:file:/home/zeinab/.m2/repository/org/clojure/clojure/1.10.1/clojure-1.10.1.jar!/clojure/pprint.clj",1614164416000,"jar:file:/home/zeinab/.m2/repository/org/clojure/tools.reader/1.3.2/tools.reader-1.3.2.jar!/clojure/tools/reader/reader_types.clj",1612959675000,"jar:file:/home/zeinab/.m2/repository/org/clojure/clojurescript/1.10.773/clojurescript-1.10.773.jar!/cljs/source_map/base64_vlq.clj",1615476662000,"jar:file:/home/zeinab/.m2/repository/org/clojure/clojurescript/1.10.773/clojurescript-1.10.773.jar!/cljs/externs.clj",1615476662000,"jar:file:/home/zeinab/.m2/repository/org/clojure/clojurescript/1.10.773/clojurescript-1.10.773.jar!/cljs/tagged_literals.cljc",1615476662000],"~:analyzer",["^ ","^3",null,"^4",["^ "],"^5",["^ ","^6","Leonardo Borges","^7","The `core` namespace provides the two main entry point functions in bouncer:\n\n  - `validate`\n  - `valid?`\n\n\nAll other functions are meant for internal use only and shouldn't be relied upon.\n\nThe project [README](https://github.com/leonardoborges/bouncer/blob/master/README.md) should get you started,\nit's pretty comprehensive.\n\n\nIf you'd like to know more about the motivation behind `bouncer`, check the\n[announcement post](http://www.leonardoborges.com/writings/2013/01/04/bouncer-validation-lib-for-clojure/).","^8","bouncer/core.cljc","^9",1,"^:",5,"^;",1,"^<",17],"^=",["^ ","^>","^?","^@","^A","^B","^C","^D","^E","^F","^G","^H","^I"],"^J",null,"^K",["^L",[]],"^M","^N","^Q",null,"^R",["^ ","^S","^S","^T","^S","^U","^U","^V","^V","^W","^W"],"^X",["^L",["^Y"]],"~:shadow/js-access-global",["^L",["Error"]],"^Z",null,"~:defs",["^ ","~$wrap-chain",["^ ","~:protocol-inline",null,"^5",["^ ","~:private",true,"^8","bouncer/core.cljc","^<",18,"~:top-fn",["^ ","~:variadic?",true,"~:fixed-arity",2,"~:max-fixed-arity",2,"~:method-params",[["^11",["~$old-state","~$message-fn","~$fs"]]],"~:arglists",["^11",[["^41","^42","~$&","^43"]]],"~:arglists-meta",["^11",[null]]],"^:",8,"^9",133,"^;",133,"^44",["^11",["~$quote",["^11",[["^41","^42","~$&","^43"]]]]],"^7","Internal Use.\n\n  Chain of responsibility.\n\n  Takes the current state and a collection of validators `fs`\n\n  Will run all validators against `old-state` and eventually return a vector with the result - the errors map - and the new state - the original map augmented with the errors map.\n\n  See also `wrap`\n"],"^3W",true,"^M","^1G","^8","bouncer/core.cljc","^<",18,"^3X",["^ ","^3Y",true,"^3Z",2,"^3[",2,"^40",[["^11",["^41","^42","^43"]]],"^44",["^11",[["^41","^42","~$&","^43"]]],"^45",["^11",[null]]],"^40",[["^11",["^41","^42","^43"]]],"~:protocol-impl",null,"^3Z",2,"^45",["^11",[null]],"^:",1,"^3Y",true,"~:methods",[["^ ","^3Z",2,"^3Y",true,"~:tag","~$cljs.core/IVector"]],"^9",133,"~:ret-tag","~$any","^;",133,"^3[",2,"~:fn-var",true,"^44",["^11",[["^41","^42","~$&","^43"]]],"^7","Internal Use.\n\n  Chain of responsibility.\n\n  Takes the current state and a collection of validators `fs`\n\n  Will run all validators against `old-state` and eventually return a vector with the result - the errors map - and the new state - the original map augmented with the errors map.\n\n  See also `wrap`\n"],"~$wrap",["^ ","^3V",null,"^5",["^ ","^8","bouncer/core.cljc","^9",85,"^:",8,"^;",85,"^<",12,"^3W",true,"^44",["^11",["^46",["^11",[["^42","~$acc",["~$pred","~$k","~$&","~$args"]]]]]],"^7","Wraps pred in the context of validating a single value\n\n  - `acc`  is the map being validated\n\n  - `pred` is a validator\n\n  - `k`    the path to the value to be validated in the associative structure `acc`\n\n  - `args` any extra args to pred\n\n  It only runs pred if:\n\n  - the validator contains a pre-condition *and* it is met or;\n  - the validator is optional  *and* there is a non-nil value to be validated (this information is read from pred's metadata) or;\n  - there are no previous errors for the given path\n\n  Returns `acc` augmented with a namespace qualified ::errors keyword\n"],"^3W",true,"^M","^1X","^8","bouncer/core.cljc","^<",12,"^40",["^11",[["^42","^4?","~$p__65722"]]],"^47",null,"^45",["^11",[null,null]],"^:",1,"^3Y",false,"^9",85,"^4;",["^L",[null,"~$clj","^4<"]],"^;",85,"^3[",3,"^4=",true,"^44",["^11",["^46",["^11",[["^42","^4?",["^4@","~$k","~$&","^4A"]]]]]],"^7","Wraps pred in the context of validating a single value\n\n  - `acc`  is the map being validated\n\n  - `pred` is a validator\n\n  - `k`    the path to the value to be validated in the associative structure `acc`\n\n  - `args` any extra args to pred\n\n  It only runs pred if:\n\n  - the validator contains a pre-condition *and* it is met or;\n  - the validator is optional  *and* there is a non-nil value to be validated (this information is read from pred's metadata) or;\n  - there are no previous errors for the given path\n\n  Returns `acc` augmented with a namespace qualified ::errors keyword\n"],"~$validate*",["^ ","^3V",null,"^5",["^ ","^8","bouncer/core.cljc","^9",150,"^:",8,"^;",150,"^<",17,"^3W",true,"^44",["^11",["^46",["^11",[["^42","~$m","^43"]]]]],"^7","Internal use.\n\n  Validates the map m using the validation functions fs.\n\n  Returns a vector where the first element is the map of validation errors if any and the second is the original map (possibly) augmented with the errors map."],"^3W",true,"^M","^1N","^8","bouncer/core.cljc","^<",17,"^40",["^11",[["^42","~$m","^43"]]],"^47",null,"^45",["^11",[null,null]],"^:",1,"^3Y",false,"^9",150,"^4;","^4:","^;",150,"^3[",3,"^4=",true,"^44",["^11",["^46",["^11",[["^42","~$m","^43"]]]]],"^7","Internal use.\n\n  Validates the map m using the validation functions fs.\n\n  Returns a vector where the first element is the map of validation errors if any and the second is the original map (possibly) augmented with the errors map."],"~$valid?",["^ ","^3V",null,"^5",["^ ","^8","bouncer/core.cljc","^9",221,"^:",7,"^;",221,"^<",13,"^44",["^11",["^46",["^11",[["~$&","^4A"]]]]],"^7","Takes a map and one or more validation functions with semantics provided by \"validate\". Returns true if the map passes all validations. False otherwise.","^3X",["^ ","^3Y",true,"^3Z",0,"^3[",0,"^40",[["^11",["^4A"]]],"^44",["^11",[["~$&","^4A"]]],"^45",["^11",[null]]]],"^M","^1V","^8","bouncer/core.cljc","^<",13,"^3X",["^ ","^3Y",true,"^3Z",0,"^3[",0,"^40",[["^11",["^4A"]]],"^44",["^11",[["~$&","^4A"]]],"^45",["^11",[null]]],"^40",[["^11",["^4A"]]],"^47",null,"^3Z",0,"^45",["^11",[null]],"^:",1,"^3Y",true,"^48",[["^ ","^3Z",0,"^3Y",true,"^49","~$boolean"]],"^9",221,"^4;","^4<","^;",221,"^3[",0,"^4=",true,"^44",["^11",[["~$&","^4A"]]],"^7","Takes a map and one or more validation functions with semantics provided by \"validate\". Returns true if the map passes all validations. False otherwise."],"~$validate",["^ ","^3V",null,"^5",["^ ","^8","bouncer/core.cljc","^9",178,"^:",7,"^;",178,"^<",15,"^44",["^11",["^46",["^11",[["~$&","^4A"]]]]],"^7","Takes a\n\n  - `message-fn` (optional) responsible for transforming error metadata into\n  the validation result (defaults to `with-default-messages`)\n\n  - `m` map to be validated\n\n  - `forms` validations to be performed on the map\n\n  forms can be a single validator set or a sequence of key/value pairs where:\n\n  key   ==> :keyword or [:a :path]\n\n  value ==> validation-function or\n            validator-set or\n           [[validation-function args+opts]] or\n           [validation-function another-validation-function] or\n           [validation-function [another-validation-function args+opts]]\n\n  e.g.:\n\n\n      (core/validate a-map\n               :name v/required\n               :age  [v/required\n                     [v/number :message \"age must be a number\"]]\n               [:passport :number] v/positive)\n\n\n  Returns a vector where the first element is the map of validation errors if\n  any and the second is the original map (possibly) augmented with the errors\n  map.\n\n  See also `defvalidator`\n","^3X",["^ ","^3Y",true,"^3Z",0,"^3[",0,"^40",[["^11",["^4A"]]],"^44",["^11",[["~$&","^4A"]]],"^45",["^11",[null]]]],"^M","^1P","^8","bouncer/core.cljc","^<",15,"^3X",["^ ","^3Y",true,"^3Z",0,"^3[",0,"^40",[["^11",["^4A"]]],"^44",["^11",[["~$&","^4A"]]],"^45",["^11",[null]]],"^40",[["^11",["^4A"]]],"^47",null,"^3Z",0,"^45",["^11",[null]],"^:",1,"^3Y",true,"^48",[["^ ","^3Z",0,"^3Y",true,"^49","^4:"]],"^9",178,"^4;","^4<","^;",178,"^3[",0,"^4=",true,"^44",["^11",[["~$&","^4A"]]],"^7","Takes a\n\n  - `message-fn` (optional) responsible for transforming error metadata into\n  the validation result (defaults to `with-default-messages`)\n\n  - `m` map to be validated\n\n  - `forms` validations to be performed on the map\n\n  forms can be a single validator set or a sequence of key/value pairs where:\n\n  key   ==> :keyword or [:a :path]\n\n  value ==> validation-function or\n            validator-set or\n           [[validation-function args+opts]] or\n           [validation-function another-validation-function] or\n           [validation-function [another-validation-function args+opts]]\n\n  e.g.:\n\n\n      (core/validate a-map\n               :name v/required\n               :age  [v/required\n                     [v/number :message \"age must be a number\"]]\n               [:passport :number] v/positive)\n\n\n  Returns a vector where the first element is the map of validation errors if\n  any and the second is the original map (possibly) augmented with the errors\n  map.\n\n  See also `defvalidator`\n"],"~$build-multi-step",["^ ","^3V",null,"^5",["^ ","^8","bouncer/core.cljc","^9",24,"^:",8,"^;",24,"^<",24,"^3W",true,"^44",["^11",["^46",["^11",[["~$key-or-vec","~$fn-vec"],["^4I",["~$f-or-list","~$&","~$rest"],"^4?"]]]]],"^3X",["^ ","^3Y",false,"^3Z",3,"^3[",3,"^40",[["^4I","^4J"],["^4I",["^4K","~$&","^4L"],"^4?"]],"^44",["^11",[["^4I","^4J"],["^4I",["^4K","~$&","^4L"],"^4?"]]],"^45",["^11",[null,null]]]],"^3W",true,"^M","^1T","^8","bouncer/core.cljc","^<",24,"^3X",["^ ","^3Y",false,"^3Z",3,"^3[",3,"^40",[["^4I","^4J"],["^4I",["^4K","~$&","^4L"],"^4?"]],"^44",["^11",[["^4I","^4J"],["^4I",["^4K","~$&","^4L"],"^4?"]]],"^45",["^11",[null,null]]],"^40",[["^4I","^4J"],["^4I",["^4K","~$&","^4L"],"^4?"]],"^47",null,"^3Z",3,"^45",["^11",[null,null]],"^:",1,"^3Y",false,"^48",[["^ ","^3Z",2,"^3Y",false,"^49","^4<"],["^ ","^3Z",3,"^3Y",false]],"^9",24,"^;",24,"^3[",3,"^4=",true,"^44",["^11",[["^4I","^4J"],["^4I",["^4K","~$&","^4L"],"^4?"]]]],"~$build-steps",["^ ","^3V",null,"^5",["^ ","^8","bouncer/core.cljc","^9",64,"^:",8,"^;",64,"^<",19,"^3W",true,"^44",["^11",["^46",["^11",[[["~$head","~$&","~$tail","^13","~$forms"]]]]]]],"^3W",true,"^M","^1[","^8","bouncer/core.cljc","^<",19,"^40",["^11",[["~$p__65711"]]],"^47",null,"^45",["^11",[null,null]],"^:",1,"^3Y",false,"^9",64,"^4;",["^L",[null,"^4<"]],"^;",64,"^3[",1,"^4=",true,"^44",["^11",["^46",["^11",[[["^4N","~$&","^4O","^13","^4P"]]]]]]],"~$pre-condition-met?",["^ ","^3V",null,"^5",["^ ","^8","bouncer/core.cljc","^9",82,"^:",8,"^;",82,"^<",26,"^3W",true,"^44",["^11",["^46",["^11",[["~$pre-fn","~$map"]]]]]],"^3W",true,"^M","^1Y","^8","bouncer/core.cljc","^<",26,"^40",["^11",[["^4S","^4T"]]],"^47",null,"^45",["^11",[null,null]],"^:",1,"^3Y",false,"^9",82,"^4;",["^L",["^4F","^4<"]],"^;",82,"^3[",2,"^4=",true,"^44",["^11",["^46",["^11",[["^4S","^4T"]]]]]],"~$merge-path",["^ ","^3V",null,"^5",["^ ","^8","bouncer/core.cljc","^9",40,"^:",8,"^;",40,"^<",18,"^3W",true,"^44",["^11",["^46",["^11",[["~$parent-key","~$validations-map"]]]]],"^7","Takes two arguments:\n\n  `parent-keyword` is a :keyword - or a vector of :keywords denoting a path in a associative structure\n\n  `validations-map` is a map of forms following this spec:\n\n\n      {:keyword [f g] :another-keyword h}\n\n\n  Merges `:parent-keyword` with every first element of validations-map, transforming it into:\n\n\n      ([:parent-keyword :keyword] [f g] [:parent-keyword :another-keyword] h)\n"],"^3W",true,"^M","^1I","^8","bouncer/core.cljc","^<",18,"^40",["^11",[["^4V","^4W"]]],"^47",null,"^45",["^11",[null,null]],"^:",1,"^3Y",false,"^9",40,"^4;","^4<","^;",40,"^3[",2,"^4=",true,"^44",["^11",["^46",["^11",[["^4V","^4W"]]]]],"^7","Takes two arguments:\n\n  `parent-keyword` is a :keyword - or a vector of :keywords denoting a path in a associative structure\n\n  `validations-map` is a map of forms following this spec:\n\n\n      {:keyword [f g] :another-keyword h}\n\n\n  Merges `:parent-keyword` with every first element of validations-map, transforming it into:\n\n\n      ([:parent-keyword :keyword] [f g] [:parent-keyword :another-keyword] h)\n"],"~$with-default-messages",["^ ","^3V",null,"^5",["^ ","^8","bouncer/core.cljc","^9",165,"^:",7,"^;",165,"^<",28,"^44",["^11",["^46",["^11",[["~$error"]]]]],"^7","Use together with `validate`, e.g.:\n\n\n      (core/validate core/with-default-messages {}\n                     :name v/required)"],"^M","^25","^8","bouncer/core.cljc","^<",28,"^40",["^11",[["^4Y"]]],"^47",null,"^45",["^11",[null,null]],"^:",1,"^3Y",false,"^9",165,"^4;","^4<","^;",165,"^3[",1,"^4=",true,"^44",["^11",["^46",["^11",[["^4Y"]]]]],"^7","Use together with `validate`, e.g.:\n\n\n      (core/validate core/with-default-messages {}\n                     :name v/required)"]],"^[",["^ ","^V","^V"],"~:cljs.analyzer/constants",["^ ","^X",["^L",["~:args","~:path","~:pre","~:else","~:value","~:bouncer.core/errors","~:optional","~:metadata","~:default-message-format","~:message"]],"~:order",["^52","^54","^55","^57","^58","^51","^50","^53","^4[","^56"]],"^14",["^ ","^Y",["^L",[]]],"^15",["^ "],"^16",["^W","^V","^S","^U"]],"^P","^N","~:ns-specs",["^ "],"~:ns-spec-vars",["^L",[]],"~:compiler-options",["^27",[["^5<","~:static-fns"],true,["^5<","~:shadow-tweaks"],null,["^5<","~:source-map-inline"],null,["^5<","~:elide-asserts"],false,["^5<","~:optimize-constants"],null,["^5<","^1;"],null,["^5<","~:external-config"],null,["^5<","~:tooling-config"],null,["^5<","~:emit-constants"],null,["^5<","~:load-tests"],null,["^5<","~:form-size-threshold"],null,["^5<","~:data-readers"],null,["^5<","~:infer-externs"],"~:auto",["^5<","^1="],null,["~:js-options","~:js-provider"],"~:shadow",["~:mode"],"~:dev",["^5<","~:fn-invoke-direct"],null,["^5<","~:source-map"],"/dev/null"]]]