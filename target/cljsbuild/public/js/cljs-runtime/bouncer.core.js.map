{"version":3,"sources":["bouncer/core.cljc"],"mappings":"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","names":["var_args","G__65689","bouncer.core/build-multi-step","js/Error","p__65694","vec__65695","seq__65696","cljs.core/seq","first__65697","cljs.core/first","cljs.core/next","key-or-vec","fn-vec","bouncer.core.build_multi_step","f-or-list","rest","acc","cljs.core/not","cljs.core/sequential?","vec__65698","seq__65699","first__65700","f","opts","cljs.core.conj","cljs.core.concat","bouncer.core/merge-path","parent-key","validations-map","cljs.core/Keyword","cljs.core.mapcat","p__65703","vec__65704","cljs.core.nth","key","validations","cljs.core/vector?","cljs.core.apply","cljs.core/vector","p__65711","vec__65712","seq__65713","first__65714","bouncer.core/build-steps","head","tail","forms","cljs.core/map?","cljs.core/vec","cljs.core/identity","cljs.core.reduce","p__65716","vec__65717","sym-or-coll","rule","G__65720","cljs.core.partition","bouncer.core/pre-condition-met?","pre-fn","map","or__4126__auto__","p__65722","vec__65723","seq__65724","first__65725","bouncer.core/wrap","message-fn","pred","k","args","map__65726","cljs.core/PROTOCOL_SENTINEL","cljs.core/hash-map","cljs.core.get","vec__65727","map__65730","error-path","cljs.core/cons","optional","default-message-format","metadata","cljs.core/meta","meta-with-defaults","cljs.core.merge","cljs.core/split-with","cljs.core/complement","cljs.core/keyword?","message","pre","pred-subject","cljs.core.get_in","and__4115__auto__","cljs.core/empty?","p1__65721#","cljs.core.update_in","G__65735","args__4742__auto__","len__4736__auto__","i__4737__auto__","argseq__4743__auto__","cljs.core/IndexedSeq","bouncer.core/wrap-chain","seq65736","G__65737","G__65738","self__4723__auto__","old-state","fs","new-state","cljs.core.partial","bouncer.core/validate*","m","G__65742","vec__65743","vec__65746","errors","state","ret","bouncer.core.wrap_chain","cljs.core/rest","bouncer.core/with-default-messages","error","map__65749","path","goog.string/format","cljs.core/name","cljs.core/peek","bouncer.core/validate","seq65751","self__4724__auto__","vec__65752","vec__65755","cljs.core/fn?","bouncer.core/valid?","seq65758"],"sourcesContent":["(ns bouncer.core\n  \"The `core` namespace provides the two main entry point functions in bouncer:\n\n  - `validate`\n  - `valid?`\n\n\nAll other functions are meant for internal use only and shouldn't be relied upon.\n\nThe project [README](https://github.com/leonardoborges/bouncer/blob/master/README.md) should get you started,\nit's pretty comprehensive.\n\n\nIf you'd like to know more about the motivation behind `bouncer`, check the\n[announcement post](http://www.leonardoborges.com/writings/2013/01/04/bouncer-validation-lib-for-clojure/).\"\n  {:author \"Leonardo Borges\"}\n  #?(:cljs (:require [goog.string :as gstring]\n                     [goog.string.format])))\n\n\n\n;; ## Internal utility functions\n\n(defn- build-multi-step\n  ([key-or-vec fn-vec] (build-multi-step key-or-vec fn-vec []))\n  ([key-or-vec [f-or-list & rest] acc]\n   (if-not f-or-list\n     acc\n     (cond\n       (sequential? f-or-list)\n       (let [[f & opts] f-or-list]\n         (recur key-or-vec\n                rest\n                (conj acc (concat [f key-or-vec] opts))))\n\n       :else (recur key-or-vec\n                    rest\n                    (conj acc [f-or-list key-or-vec]))))))\n\n(defn- merge-path\n  \"Takes two arguments:\n\n  `parent-keyword` is a :keyword - or a vector of :keywords denoting a path in a associative structure\n\n  `validations-map` is a map of forms following this spec:\n\n\n      {:keyword [f g] :another-keyword h}\n\n\n  Merges `:parent-keyword` with every first element of validations-map, transforming it into:\n\n\n      ([:parent-keyword :keyword] [f g] [:parent-keyword :another-keyword] h)\n\"\n  [parent-key validations-map]\n  (let [parent-key (if (keyword? parent-key) [parent-key] parent-key)]\n    (mapcat (fn [[key validations]]\n              (if (vector? key)\n                [(apply vector (concat parent-key key)) validations]\n                [(apply vector (concat parent-key [key])) validations]))\n            validations-map)))\n\n(defn- build-steps [[head & tail :as forms]]\n  (let [forms (if (map? head)\n                (vec (mapcat identity head))\n                forms)]\n    (reduce (fn [acc [key-or-vec sym-or-coll :as rule]]\n              (cond\n                (vector? sym-or-coll)\n                (concat acc (build-multi-step key-or-vec sym-or-coll))\n\n\n                (map? sym-or-coll)\n                (concat acc (build-steps (merge-path key-or-vec\n                                                     sym-or-coll)))\n\n                :else (conj acc [sym-or-coll key-or-vec])))\n            []\n            (partition 2 forms))))\n\n(defn- pre-condition-met? [pre-fn map]\n  (or (nil? pre-fn) (pre-fn map)))\n\n(defn- wrap\n  \"Wraps pred in the context of validating a single value\n\n  - `acc`  is the map being validated\n\n  - `pred` is a validator\n\n  - `k`    the path to the value to be validated in the associative structure `acc`\n\n  - `args` any extra args to pred\n\n  It only runs pred if:\n\n  - the validator contains a pre-condition *and* it is met or;\n  - the validator is optional  *and* there is a non-nil value to be validated (this information is read from pred's metadata) or;\n  - there are no previous errors for the given path\n\n  Returns `acc` augmented with a namespace qualified ::errors keyword\n\"\n  [message-fn acc [pred k & args]]\n  (let [k            (if (vector? k) k [k])\n        error-path   (cons ::errors k)\n\n        {:keys [optional default-message-format]\n         :or   {optional               false\n                default-message-format \"Custom validation failed for %s\"}\n         :as   metadata} (meta pred)\n\n        meta-with-defaults\n                     (merge metadata {:default-message-format default-message-format\n                                      :optional               optional})\n\n        [args opts] (split-with (complement keyword?) args)\n        {:keys [message pre]} (apply hash-map opts)\n        pred-subject (get-in acc k)]\n    (if (pre-condition-met? pre acc)\n      (if (or (and optional (nil? pred-subject))\n              (not (empty? (get-in acc error-path)))\n              (apply pred pred-subject args))\n        acc\n        (update-in acc error-path\n                   #(conj % (message-fn {:path     k, :value pred-subject\n                                         :args     (seq args)\n                                         :metadata meta-with-defaults\n                                         :message  message}))))\n      acc)))\n\n\n(defn- wrap-chain\n  \"Internal Use.\n\n  Chain of responsibility.\n\n  Takes the current state and a collection of validators `fs`\n\n  Will run all validators against `old-state` and eventually return a vector with the result - the errors map - and the new state - the original map augmented with the errors map.\n\n  See also `wrap`\n\"\n  [old-state message-fn & fs]\n  (let [new-state (reduce (partial wrap message-fn)\n                          old-state\n                          fs)]\n    [(::errors new-state) new-state]))\n\n(defn- validate*\n  \"Internal use.\n\n  Validates the map m using the validation functions fs.\n\n  Returns a vector where the first element is the map of validation errors if any and the second is the original map (possibly) augmented with the errors map.\"\n  [message-fn m fs]\n  (loop [[errors state :as ret] [nil m]\n         fs fs]\n    (if (seq fs)\n      (recur (wrap-chain state message-fn (first fs)) (rest fs))\n      ret)))\n\n;; ## Public API\n\n(defn with-default-messages\n  \"Use together with `validate`, e.g.:\n\n\n      (core/validate core/with-default-messages {}\n                     :name v/required)\"\n  [error]\n  (let [{:keys [message path metadata]} error]\n    #?(:clj (format (or message (:default-message-format metadata))\n                    (name (peek path))))\n    #?(:cljs (gstring/format (or message (:default-message-format metadata))\n                             (name (peek path))))))\n\n(defn validate\n  \"Takes a\n\n  - `message-fn` (optional) responsible for transforming error metadata into\n  the validation result (defaults to `with-default-messages`)\n\n  - `m` map to be validated\n\n  - `forms` validations to be performed on the map\n\n  forms can be a single validator set or a sequence of key/value pairs where:\n\n  key   ==> :keyword or [:a :path]\n\n  value ==> validation-function or\n            validator-set or\n           [[validation-function args+opts]] or\n           [validation-function another-validation-function] or\n           [validation-function [another-validation-function args+opts]]\n\n  e.g.:\n\n\n      (core/validate a-map\n               :name v/required\n               :age  [v/required\n                     [v/number :message \\\"age must be a number\\\"]]\n               [:passport :number] v/positive)\n\n\n  Returns a vector where the first element is the map of validation errors if\n  any and the second is the original map (possibly) augmented with the errors\n  map.\n\n  See also `defvalidator`\n\"\n  [& args]\n  (let [[message-fn args] (if (fn? (first args))\n                            [(first args) (next args)]\n                            [with-default-messages args])\n        [m forms] [(first args) (next args)]]\n    (validate* message-fn m (build-steps forms))))\n\n(defn valid?\n  \"Takes a map and one or more validation functions with semantics provided by \\\"validate\\\". Returns true if the map passes all validations. False otherwise.\"\n  [& args]\n  (empty? (first (apply validate args))))\n"]}