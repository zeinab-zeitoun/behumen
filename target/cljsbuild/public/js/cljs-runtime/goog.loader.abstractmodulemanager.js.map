{
"version":3,
"file":"goog.loader.abstractmodulemanager.js",
"lineCount":69,
"mappings":"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",
"sources":["goog/loader/abstractmodulemanager.js"],
"sourcesContent":["// Copyright 2017 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * @fileoverview The interface for module managers. The default implementation\n * is goog.module.ModuleManager.\n */\n\ngoog.provide('goog.loader.AbstractModuleManager');\ngoog.provide('goog.loader.AbstractModuleManager.CallbackType');\ngoog.provide('goog.loader.AbstractModuleManager.FailureType');\n\ngoog.require('goog.module.AbstractModuleLoader');\ngoog.require('goog.module.ModuleInfo');\ngoog.require('goog.module.ModuleLoadCallback');\n\n\n\n/**\n * The ModuleManager keeps track of all modules in the environment.\n * Since modules may not have their code loaded, we must keep track of them.\n * @abstract\n * @constructor\n * @struct\n */\ngoog.loader.AbstractModuleManager = function() {\n  /**\n   * The module context needed for module initialization.\n   * @private {?Object}\n   */\n  this.moduleContext_ = null;\n\n  /**\n   * A loader for the modules that implements loadModules(ids, moduleInfoMap,\n   * opt_successFn, opt_errorFn, opt_timeoutFn, opt_forceReload) method.\n   * @private {?goog.module.AbstractModuleLoader}\n   */\n  this.loader_ = null;\n};\n\n\n/**\n * The type of callbacks that can be registered with the module manager,.\n * @enum {string}\n */\ngoog.loader.AbstractModuleManager.CallbackType = {\n  /**\n   * Fired when an error has occurred.\n   */\n  ERROR: 'error',\n\n  /**\n   * Fired when it becomes idle and has no more module loads to process.\n   */\n  IDLE: 'idle',\n\n  /**\n   * Fired when it becomes active and has module loads to process.\n   */\n  ACTIVE: 'active',\n\n  /**\n   * Fired when it becomes idle and has no more user-initiated module loads to\n   * process.\n   */\n  USER_IDLE: 'userIdle',\n\n  /**\n   * Fired when it becomes active and has user-initiated module loads to\n   * process.\n   */\n  USER_ACTIVE: 'userActive'\n};\n\n\n/**\n * The possible reasons for a module load failure callback being fired.\n * @enum {number}\n */\ngoog.loader.AbstractModuleManager.FailureType = {\n  /** 401 Status. */\n  UNAUTHORIZED: 0,\n\n  /** Error status (not 401) returned multiple times. */\n  CONSECUTIVE_FAILURES: 1,\n\n  /** Request timeout. */\n  TIMEOUT: 2,\n\n  /** 410 status, old code gone. */\n  OLD_CODE_GONE: 3,\n\n  /** The onLoad callbacks failed. */\n  INIT_ERROR: 4\n};\n\n\n/**\n * A non-HTTP status code indicating a corruption in loaded module.\n * This should be used by a ModuleLoader as a replacement for the HTTP code\n * given to the error handler function to indicated that the module was\n * corrupted.\n * This will set the forceReload flag on the loadModules method when retrying\n * module loading.\n * @type {number}\n */\ngoog.loader.AbstractModuleManager.CORRUPT_RESPONSE_STATUS_CODE = 8001;\n\n\n/**\n * Sets the batch mode as enabled or disabled for the module manager.\n * @param {boolean} enabled Whether the batch mode is to be enabled or not.\n */\ngoog.loader.AbstractModuleManager.prototype.setBatchModeEnabled = function(\n    enabled) {};\n\n\n/**\n * Sets the concurrent loading mode as enabled or disabled for the module\n * manager. Requires a moduleloader implementation that supports concurrent\n * loads. The default {@see goog.module.ModuleLoader} does not.\n * @param {boolean} enabled\n */\ngoog.loader.AbstractModuleManager.prototype.setConcurrentLoadingEnabled =\n    function(enabled) {};\n\n\n/**\n * Sets the module info for all modules. Should only be called once.\n *\n * @param {!Object<!Array<string>>} infoMap An object that contains a mapping\n *    from module id (String) to list of required module ids (Array).\n */\ngoog.loader.AbstractModuleManager.prototype.setAllModuleInfo = function(\n    infoMap) {};\n\n\n/**\n * Sets the module info for all modules. Should only be called once. Also\n * marks modules that are currently being loaded.\n *\n * @param {string=} opt_info A string representation of the module dependency\n *      graph, in the form: module1:dep1,dep2/module2:dep1,dep2 etc.\n *     Where depX is the base-36 encoded position of the dep in the module list.\n * @param {!Array<string>=} opt_loadingModuleIds A list of moduleIds that\n *     are currently being loaded.\n */\ngoog.loader.AbstractModuleManager.prototype.setAllModuleInfoString = function(\n    opt_info, opt_loadingModuleIds) {};\n\n\n/**\n * Gets a module info object by id.\n * @param {string} id A module identifier.\n * @return {!goog.module.ModuleInfo} The module info.\n * @abstract\n */\ngoog.loader.AbstractModuleManager.prototype.getModuleInfo = function(id) {};\n\n\n/**\n * Sets the module uris.\n * @param {!Object<string, !Array<!goog.html.TrustedResourceUrl>>} moduleUriMap\n *     The map of id/uris pairs for each module.\n */\ngoog.loader.AbstractModuleManager.prototype.setModuleTrustedUris = function(\n    moduleUriMap) {};\n\n\n/**\n * Gets the application-specific module loader.\n * @return {?goog.module.AbstractModuleLoader} An object that has a\n *     loadModules(ids, moduleInfoMap, opt_successFn, opt_errFn,\n *         opt_timeoutFn, opt_forceReload) method.\n */\ngoog.loader.AbstractModuleManager.prototype.getLoader = function() {\n  return this.loader_;\n};\n\n\n/**\n * Sets the application-specific module loader.\n * @param {!goog.module.AbstractModuleLoader} loader An object that has a\n *     loadModules(ids, moduleInfoMap, opt_successFn, opt_errFn,\n *         opt_timeoutFn, opt_forceReload) method.\n */\ngoog.loader.AbstractModuleManager.prototype.setLoader = function(loader) {\n  this.loader_ = loader;\n};\n\n\n/**\n * Gets the module context to use to initialize the module.\n * @return {?Object} The context.\n */\ngoog.loader.AbstractModuleManager.prototype.getModuleContext = function() {\n  return this.moduleContext_;\n};\n\n\n/**\n * Sets the module context to use to initialize the module.\n * @param {!Object} context The context.\n */\ngoog.loader.AbstractModuleManager.prototype.setModuleContext = function(\n    context) {\n  this.moduleContext_ = context;\n};\n\n\n/**\n * Determines if the ModuleManager is active\n * @return {boolean} TRUE iff the ModuleManager is active (i.e., not idle).\n */\ngoog.loader.AbstractModuleManager.prototype.isActive = function() {\n  return false;\n};\n\n\n/**\n * Determines if the ModuleManager is user active\n * @return {boolean} TRUE iff the ModuleManager is user active (i.e., not idle).\n */\ngoog.loader.AbstractModuleManager.prototype.isUserActive = function() {\n  return false;\n};\n\n\n/**\n * Preloads a module after a short delay.\n *\n * @param {string} id The id of the module to preload.\n * @param {number=} opt_timeout The number of ms to wait before adding the\n *     module id to the loading queue (defaults to 0 ms). Note that the module\n *     will be loaded asynchronously regardless of the value of this parameter.\n * @return {!IThenable}\n * @abstract\n */\ngoog.loader.AbstractModuleManager.prototype.preloadModule = function(\n    id, opt_timeout) {};\n\n\n/**\n * Prefetches a JavaScript module and its dependencies, which means that the\n * module will be downloaded, but not evaluated. To complete the module load,\n * the caller should also call load or execOnLoad after prefetching the module.\n *\n * @param {string} id The id of the module to prefetch.\n */\ngoog.loader.AbstractModuleManager.prototype.prefetchModule = function(id) {\n  throw new Error('prefetchModule is not implemented.');\n};\n\n\n/**\n * Records that the currently loading module was loaded. Also initiates loading\n * the next module if any module requests are queued. This method is called by\n * code that is generated and appended to each dynamic module's code at\n * compilation time.\n *\n * @abstract\n */\ngoog.loader.AbstractModuleManager.prototype.setLoaded = function() {};\n\n\n/**\n * Gets whether a module is currently loading or in the queue, waiting to be\n * loaded.\n * @param {string} id A module id.\n * @return {boolean} TRUE iff the module is loading.\n * @abstract\n */\ngoog.loader.AbstractModuleManager.prototype.isModuleLoading = function(id) {};\n\n\n/**\n * Requests that a function be called once a particular module is loaded.\n * Client code can use this method to safely call into modules that may not yet\n * be loaded. For consistency, this method always calls the function\n * asynchronously -- even if the module is already loaded. Initiates loading of\n * the module if necessary, unless opt_noLoad is true.\n *\n * @param {string} moduleId A module id.\n * @param {!Function} fn Function to execute when the module has loaded.\n * @param {!Object=} opt_handler Optional handler under whose scope to execute\n *     the callback.\n * @param {boolean=} opt_noLoad TRUE iff not to initiate loading of the module.\n * @param {boolean=} opt_userInitiated TRUE iff the loading of the module was\n *     user initiated.\n * @param {boolean=} opt_preferSynchronous TRUE iff the function should be\n *     executed synchronously if the module has already been loaded.\n * @return {!goog.module.ModuleLoadCallback} A callback wrapper that exposes\n *     an abort and execute method.\n * @abstract\n */\ngoog.loader.AbstractModuleManager.prototype.execOnLoad = function(\n    moduleId, fn, opt_handler, opt_noLoad, opt_userInitiated,\n    opt_preferSynchronous) {};\n\n\n/**\n * Loads a module, returning an IThenable for keeping track of the result.\n *\n * @param {string} moduleId A module id.\n * @param {boolean=} opt_userInitiated If the load is a result of a user action.\n * @return {!IThenable} A deferred object.\n * @abstract\n */\ngoog.loader.AbstractModuleManager.prototype.load = function(\n    moduleId, opt_userInitiated) {};\n\n\n/**\n * Loads a list of modules, returning a map of IThenables for keeping track of\n * the results.\n *\n * @param {!Array<string>} moduleIds A list of module ids.\n * @param {boolean=} opt_userInitiated If the load is a result of a user action.\n * @return {!Object<string, !IThenable>} A mapping from id (String)\n *     to deferred objects that will callback or errback when the load for that\n *     id is finished.\n * @abstract\n */\ngoog.loader.AbstractModuleManager.prototype.loadMultiple = function(\n    moduleIds, opt_userInitiated) {};\n\n\n/**\n * Method called just before module code is loaded.\n * @param {string} id Identifier of the module.\n * @abstract\n */\ngoog.loader.AbstractModuleManager.prototype.beforeLoadModuleCode = function(\n    id) {};\n\n\n/**\n * Register an initialization callback for the currently loading module. This\n * should only be called by script that is executed during the evaluation of\n * a module's javascript. This is almost equivalent to calling the function\n * inline, but ensures that all the code from the currently loading module\n * has been loaded. This makes it cleaner and more robust than calling the\n * function inline.\n *\n * If this function is called from the base module (the one that contains\n * the module manager code), the callback is held until #setAllModuleInfo\n * is called, or until #setModuleContext is called, whichever happens first.\n *\n * @param {!Function} fn A callback function that takes a single argument\n *    which is the module context.\n * @param {!Object=} opt_handler Optional handler under whose scope to execute\n *     the callback.\n */\ngoog.loader.AbstractModuleManager.prototype.registerInitializationCallback =\n    function(fn, opt_handler) {};\n\n\n/**\n * Register a late initialization callback for the currently loading module.\n * Callbacks registered via this function are executed similar to\n * {@see registerInitializationCallback}, but they are fired after all\n * initialization callbacks are called.\n *\n * @param {!Function} fn A callback function that takes a single argument\n *    which is the module context.\n * @param {!Object=} opt_handler Optional handler under whose scope to execute\n *     the callback.\n */\ngoog.loader.AbstractModuleManager.prototype.registerLateInitializationCallback =\n    function(fn, opt_handler) {};\n\n\n/**\n * Sets the constructor to use for the module object for the currently\n * loading module. The constructor should derive from\n * {@see goog.module.BaseModule}.\n * @param {!Function} fn The constructor function.\n */\ngoog.loader.AbstractModuleManager.prototype.setModuleConstructor = function(\n    fn) {};\n\n\n/**\n * The function to call if the module manager is in error.\n * @param {!goog.loader.AbstractModuleManager.CallbackType|!Array<\n *     !goog.loader.AbstractModuleManager.CallbackType>} types The callback\n *         type.\n * @param {!Function} fn The function to register as a callback.\n */\ngoog.loader.AbstractModuleManager.prototype.registerCallback = function(\n    types, fn) {};\n"],
"names":["goog","provide","require","loader","AbstractModuleManager","goog.loader.AbstractModuleManager","moduleContext_","loader_","CallbackType","ERROR","IDLE","ACTIVE","USER_IDLE","USER_ACTIVE","FailureType","UNAUTHORIZED","CONSECUTIVE_FAILURES","TIMEOUT","OLD_CODE_GONE","INIT_ERROR","CORRUPT_RESPONSE_STATUS_CODE","prototype","setBatchModeEnabled","goog.loader.AbstractModuleManager.prototype.setBatchModeEnabled","enabled","setConcurrentLoadingEnabled","goog.loader.AbstractModuleManager.prototype.setConcurrentLoadingEnabled","setAllModuleInfo","goog.loader.AbstractModuleManager.prototype.setAllModuleInfo","infoMap","setAllModuleInfoString","goog.loader.AbstractModuleManager.prototype.setAllModuleInfoString","opt_info","opt_loadingModuleIds","getModuleInfo","goog.loader.AbstractModuleManager.prototype.getModuleInfo","id","setModuleTrustedUris","goog.loader.AbstractModuleManager.prototype.setModuleTrustedUris","moduleUriMap","getLoader","goog.loader.AbstractModuleManager.prototype.getLoader","setLoader","goog.loader.AbstractModuleManager.prototype.setLoader","getModuleContext","goog.loader.AbstractModuleManager.prototype.getModuleContext","setModuleContext","goog.loader.AbstractModuleManager.prototype.setModuleContext","context","isActive","goog.loader.AbstractModuleManager.prototype.isActive","isUserActive","goog.loader.AbstractModuleManager.prototype.isUserActive","preloadModule","goog.loader.AbstractModuleManager.prototype.preloadModule","opt_timeout","prefetchModule","goog.loader.AbstractModuleManager.prototype.prefetchModule","Error","setLoaded","goog.loader.AbstractModuleManager.prototype.setLoaded","isModuleLoading","goog.loader.AbstractModuleManager.prototype.isModuleLoading","execOnLoad","goog.loader.AbstractModuleManager.prototype.execOnLoad","moduleId","fn","opt_handler","opt_noLoad","opt_userInitiated","opt_preferSynchronous","load","goog.loader.AbstractModuleManager.prototype.load","loadMultiple","goog.loader.AbstractModuleManager.prototype.loadMultiple","moduleIds","beforeLoadModuleCode","goog.loader.AbstractModuleManager.prototype.beforeLoadModuleCode","registerInitializationCallback","goog.loader.AbstractModuleManager.prototype.registerInitializationCallback","registerLateInitializationCallback","goog.loader.AbstractModuleManager.prototype.registerLateInitializationCallback","setModuleConstructor","goog.loader.AbstractModuleManager.prototype.setModuleConstructor","registerCallback","goog.loader.AbstractModuleManager.prototype.registerCallback","types"]
}
